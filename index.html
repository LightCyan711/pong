<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>PONG — AI / Player / 멀티</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<style>
  :root{
    --bg:#0B1020; --ink:#EAF0FF; --muted:#90A0C0; --line:#1D2540;
    --card:#0E1430; --blue:#5B7CFF; --coral:#FF6E5A;
    --shadow:0 20px 60px rgba(0,10,40,.4);
    --green:#22D07A; --amber:#FFB020;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1600px 900px at 50% -20%, #18224D 0%, #0B1020 55%) fixed; color:var(--ink);
    font-family:Inter,Pretendard,system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif; overflow:hidden}
  .wrap{height:100vh;display:grid;place-items:center;padding:18px}
  .card{height:calc(100vh - 36px);width:min(1100px,96vw);background:linear-gradient(180deg,#0F1638,#0B1020);
    border:1px solid #1a2144;border-radius:18px;box-shadow:var(--shadow);position:relative;padding:14px}
  .top{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .title{font-weight:900;letter-spacing:.28rem;opacity:.9}
  .badge{display:inline-flex;gap:8px;align-items:center;background:#0f1642;border:1px solid var(--line);
    border-radius:10px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%;background:#3a4268}
  .ok{background:var(--green)} .warn{background:var(--amber)}
  #gameBox{position:relative;height:calc(100% - 44px)}
  canvas{display:block;width:100%;height:100%;border-radius:14px;box-shadow:inset 0 0 0 1px #1a2144}
  .ctrl{position:absolute;left:12px;right:12px;bottom:10px;display:flex;gap:8px;align-items:center;z-index:4}
  .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;background:#111a3d;color:#fff;
    font-weight:800;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  .btn.alt{background:#2b3fe6} .btn.ghost{background:#0b122e;color:#dfe6ff;border:1px solid #1a2144}
  .overlay{position:absolute;inset:0;border-radius:14px;background:
    radial-gradient(1200px 600px at 50% -40%, rgba(91,124,255,.14), transparent 60%), rgba(12,16,36,.85);
    backdrop-filter:blur(6px) saturate(1.1);display:none;z-index:5}
  .ctr{position:absolute;inset:0;display:grid;place-items:center;padding:16px}
  .modes{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px;width:min(960px,94%)}
  .mode{border-radius:14px;padding:16px;background:linear-gradient(180deg,#0f1638,#0c122e);
    border:1px solid #1a2144;cursor:pointer;text-align:center;transition:.2s}
  .mode:hover{box-shadow:0 12px 26px rgba(91,124,255,.25);transform:translateY(-1px)}
  .small{font-size:12px;color:#9eaad0}
  .vignette{position:absolute;inset:0;border-radius:14px;pointer-events:none;box-shadow:inset 0 0 120px rgba(0,0,0,.55)}
  /* 멀티 슬라이드 */
  .slideWrap{overflow:hidden; max-height:0; transition:max-height .45s cubic-bezier(.2,.8,.2,1)}
  .slideWrap.open{max-height:360px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#0e1438;border:1px solid #1a2144;
    padding:6px 10px;border-radius:999px;font-size:12px;color:#9eaad0}
  input[type="text"]{height:40px;border-radius:10px;border:1px solid #1a2144;background:#0c1230;color:#eaf0ff;
    padding:0 12px;outline:none;min-width:160px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="top">
      <div class="title">P O N G — HYPER</div>
      <div class="badge"><span id="fps">0 fps</span><span class="dot" id="aiDot"></span><span id="aiTxt">AI: loading…</span></div>
    </div>

    <div id="gameBox">
      <canvas id="cv" width="800" height="600"></canvas>
      <div class="vignette"></div>

      <!-- Title -->
      <section id="titleOv" class="overlay" style="display:block;cursor:pointer">
        <div class="ctr">
          <div style="display:grid;gap:18px;place-items:center">
            <h1 style="margin:0;font-size:62px;letter-spacing:.7rem">P o n g</h1>
            <div class="small">화면을 클릭하거나 Enter</div>
          </div>
        </div>
      </section>

      <!-- Mode -->
      <section id="modeOv" class="overlay">
        <div class="ctr" style="gap:14px">
          <h2 style="margin:0 0 6px;font-size:30px">모드 선택</h2>
          <div class="modes">
            <div class="mode" data-mode="aiai"><h3>AI vs AI</h3><div class="small">양쪽 모두 ONNX(실패 시 휴리스틱)</div></div>
            <div class="mode" data-mode="aip"><h3>AI vs 플레이어</h3><div class="small">오른쪽: 당신(↑/↓ 또는 W/S)</div></div>
            <div class="mode" id="multiBtn"><h3>멀티플레이(P2P)</h3><div class="small">1v1 일반 퐁 · 6자리 코드</div></div>
          </div>

          <!-- 멀티 슬라이더 -->
          <div id="multiSlide" class="slideWrap" style="width:min(960px,94%);margin-top:10px">
            <div style="border:1px solid #1a2144;border-radius:14px;padding:12px;background:#0c122e">
              <div class="row" style="align-items:center;justify-content:space-between">
                <div class="row">
                  <button id="btnHost" class="btn alt">호스트</button>
                  <button id="btnJoin" class="btn">참여</button>
                </div>
                <div class="row">
                  <span class="pill">상태: <b id="netState">대기</b></span>
                  <span class="pill">코드: <b id="roomCode">— — — — — —</b></span>
                  <button id="btnCopy" class="btn ghost">코드 복사</button>
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <input id="nick" type="text" placeholder="닉네임(선택)" maxlength="12"/>
                <input id="codeInput" type="text" placeholder="참여용 6자리 코드" maxlength="6"/>
                <button id="btnConnect" class="btn alt">연결</button>
                <button id="btnStartNet" class="btn" disabled>게임 시작</button>
              </div>
              <div class="small" style="margin-top:8px; color:#9eaad0">
                호스트가 생성한 6자리 코드를 공유하고, 참여자는 코드를 입력해 연결합니다. (WebRTC P2P / PeerJS)
              </div>
            </div>
          </div>

          <div class="small" style="margin-top:8px">일시정지 P · 재시작 R</div>
        </div>
      </section>

      <!-- Finish -->
      <section id="postOv" class="overlay">
        <div class="ctr" id="postInner"></div>
      </section>

      <!-- Controls -->
      <div class="ctrl">
        <button id="btnTitle" class="btn ghost">타이틀</button>
        <button id="btnReset" class="btn">재시작</button>
        <button id="btnPause" class="btn alt">일시정지</button>
        <div style="margin-left:auto;font-weight:900"><span id="time">–:––</span></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/* ====== Core constants (가속/연출 유지) ====== */
const W=800,H=600,PW=12,PH=88,BR=8;
const PAD_SPEED=460;
const B_INIT=400, B_MAX=1200, GROW_HIT=1.12, GROW_WALL=1.02, ANG_MAX=(38*Math.PI)/180;
const MATCH_SEC=120;
const COLORS={L:'#5B7CFF', R:'#FF6E5A'};
const TRAIL_MAX=110;

/* ====== Canvas/DOM ====== */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
ctx.imageSmoothingEnabled=true;
const fpsEl=document.getElementById('fps'), aiDot=document.getElementById('aiDot'), aiTxt=document.getElementById('aiTxt');
const titleOv=document.getElementById('titleOv'), modeOv=document.getElementById('modeOv'), postOv=document.getElementById('postOv'), postInner=document.getElementById('postInner');
const timeEl=document.getElementById('time');
const multiBtn=document.getElementById('multiBtn'), multiSlide=document.getElementById('multiSlide');
const btnHost=document.getElementById('btnHost'), btnJoin=document.getElementById('btnJoin');
const btnConnect=document.getElementById('btnConnect'), btnStartNet=document.getElementById('btnStartNet'), btnCopy=document.getElementById('btnCopy');
const codeInput=document.getElementById('codeInput'), roomCodeEl=document.getElementById('roomCode'), netState=document.getElementById('netState'), nickEl=document.getElementById('nick');

/* ====== Game State ====== */
const S={
  scene:'title', mode:null, paused:false, last:performance.now(), run:false,
  ball:{x:W/2,y:H/2,vx:B_INIT,vy:0}, sL:0, sR:0, rallyRight:Math.random()<.5, t:MATCH_SEC,
  L:[], R:[], trail:[], speedLines:[], shake:0, scorePop:null
};
function speed(b){ return Math.hypot(b.vx,b.vy); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function setSpeedDir(b, sp, ang){ b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; }

/* ====== UI ====== */
function show(el,on){ el.style.display=on?'block':'none'; }
function bg(){
  ctx.clearRect(0,0,W,H);
  const g=ctx.createLinearGradient(0,0,W,H); g.addColorStop(0,'#0D1434'); g.addColorStop(1,'#0A0F25');
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  ctx.fillStyle='rgba(60,80,160,.35)';
  for(let y=0;y<H;y+=26) ctx.fillRect(W/2-2,y,4,13);
}
function rr(x,y,w,h,r,c){ const R=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+R,y); ctx.arcTo(x+w,y,x+w,y+h,R); ctx.arcTo(x+w,y+h,x,y+h,R); ctx.arcTo(x,y+h,x,y,R); ctx.arcTo(x,y,x+w,y,R); ctx.closePath(); ctx.fillStyle=c; ctx.fill(); }
function circle(x,y,r,c){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=c; ctx.fill(); }
function fmt(t){ const m=Math.floor(t/60), s=Math.floor(t%60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }
const Keys=new Map();
addEventListener('keydown',e=>{ Keys.set(e.code,true); if(e.code==='KeyP')S.paused=!S.paused; if(e.code==='KeyR')resetRound(); if(S.scene==='title'&&(e.code==='Enter'||e.code==='Space')) titleOv.click(); });
addEventListener('keyup',e=>Keys.set(e.code,false));
titleOv.addEventListener('click',()=>{ if(S.scene==='title'){ show(titleOv,false); show(modeOv,true); S.scene='mode'; }});
document.querySelectorAll('.mode[data-mode]').forEach(m=> m.onclick=()=>{ S.mode=m.dataset.mode; show(modeOv,false); show(postOv,false); startMode(S.mode); });
multiBtn.onclick=()=> multiSlide.classList.toggle('open');

document.getElementById('btnTitle').onclick=()=>{ disconnectNet(); S.scene='title'; S.run=false; show(titleOv,true); show(modeOv=false); show(postOv,false); };
document.getElementById('btnReset').onclick=()=> resetRound();
document.getElementById('btnPause').onclick=()=> S.paused=!S.paused;

/* ====== ONNX (AI 관측 8D/정규화 동일) ====== */
let ortSession=null, aiReady=false;
(async()=>{ try{ aiTxt.textContent='AI: loading…'; aiDot.className='dot';
  ortSession=await ort.InferenceSession.create('model.onnx',{executionProviders:['wasm']});
  aiReady=true; aiTxt.textContent='AI: loaded'; aiDot.className='dot ok';
}catch(e){ aiReady=false; aiTxt.textContent='AI: failed (heuristic)'; aiDot.className='dot warn'; }})();
function obsLeft(py,oy){
  const bx=(S.ball.x/W)*2-1, by=(S.ball.y/H)*2-1;
  const bvx=clamp(S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1);
  const p=(py/H)*2-1, o=(oy/H)*2-1;
  const rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1);
  return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);
}
function obsRightMirror(py,oy){
  const bx=((W-S.ball.x)/W)*2-1, by=(S.ball.y/H)*2-1;
  const bvx=clamp(-S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1);
  const p=(py/H)*2-1, o=(oy/H)*2-1;
  const rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1);
  return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);
}
async function aiActLeft(py,oy){ if(!aiReady) return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; try{ const r=await ortSession.run({observation:obsLeft(py,oy)}); const k=Object.keys(r)[0]; return (r[k].data||r[k])[0]|0; }catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; } }
async function aiActRight(py,oy){ if(!aiReady) return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; try{ const r=await ortSession.run({observation:obsRightMirror(py,oy)}); const k=Object.keys(r)[0]; return (r[k].data||r[k])[0]|0; }catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; } }

/* ====== 로컬 모드 ====== */
function makePaddle(side,color,upKey,downKey,aiSide){ return {y:H/2, color, upKey, downKey, aiSide, trail:[]}; }
function startMode(mode){
  disconnectNet();
  S.sL=0; S.sR=0; S.t=MATCH_SEC; S.paused=false; S.run=true; S.scene='play';
  S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  S.ball.x=W/2; S.ball.y=H/2; const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1);
  S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);
  S.L=[]; S.R=[];
  if(mode==='aiai'){ S.L.push(makePaddle('L', COLORS.L, null,null,'L')); S.R.push(makePaddle('R', COLORS.R, null,null,'R')); }
  else{ S.L.push(makePaddle('L', COLORS.L, null,null,'L')); S.R.push(makePaddle('R', COLORS.R, 'ArrowUp','ArrowDown', null)); }
}

/* ====== 공/물리 & 연출 ====== */
function apply(p, act){ const d=(act===0?-1:(act===2?1:0))*PAD_SPEED*(1/60); p.y=clamp(p.y+d, PH/2, H-PH/2); }
function circleRect(cx,cy,cr,rx,ry,rw,rh){ const nx=clamp(cx,rx,rx+rw), ny=clamp(cy,ry,ry+rh); const dx=cx-nx, dy=cy-ny; return dx*dx+dy*dy<=cr*cr; }
function screenShake(power){ S.shake=Math.max(S.shake,power); }
const sparks=[];
function spawnHitSpark(x,y,dir){ for(let i=0;i<10;i++){ const ang=(Math.random()*0.9-0.45)+(dir>0?0:Math.PI); const spd=200+Math.random()*400; sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:.25,age:0}); } }
function updateSparks(dt){ for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.age+=dt; s.x+=s.vx*dt; s.y+=s.vy*dt; s.vx*=0.96; s.vy*=0.96; if(s.age>=s.life) sparks.splice(i,1); } }
function drawSparks(){ ctx.save(); ctx.globalCompositeOperation='lighter'; for(const s of sparks){ const t=1-s.age/s.life; ctx.fillStyle=`rgba(255,180,80,${0.6*t})`; ctx.beginPath(); ctx.arc(s.x,s.y,2+3*t,0,Math.PI*2); ctx.fill(); } ctx.restore(); }
function spawnSpeedLines(vx,vy){ const sp=Math.hypot(vx,vy), n=Math.floor(clamp((sp-500)/80,0,10)); for(let i=0;i<n;i++){ const ang=Math.atan2(vy,vx)+(Math.random()*0.4-0.2); const len=30+Math.random()*90; const x=S.ball.x-Math.cos(ang)*8, y=S.ball.y-Math.sin(ang)*8; S.speedLines.push({x,y,ang,len,age:0,life:.18}); } if(S.speedLines.length>60) S.speedLines.splice(0,S.speedLines.length-60); }
function updateSpeedLines(dt){ for(let i=S.speedLines.length-1;i>=0;i--){ const l=S.speedLines[i]; l.age+=dt; l.x-=Math.cos(l.ang)*S.ball.vx*dt*0.2; l.y-=Math.sin(l.ang)*S.ball.vy*dt*0.2; if(l.age>=l.life) S.speedLines.splice(i,1); } }
function drawSpeedLines(){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,180,255,.45)'; ctx.lineWidth=2; for(const l of S.speedLines){ const t=1-l.age/l.life, dx=Math.cos(l.ang)*l.len*t, dy=Math.sin(l.ang)*l.len*t; ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(l.x-dx,l.y-dy); ctx.stroke(); } ctx.restore(); }
function pushPaddleTrail(side){ const p = side==='L'?S.L[0]:S.R[0]; if(!p) return; const arr=p.trail; arr.unshift({y:p.y}); if(arr.length>10) arr.length=10; }
function drawPaddleTrail(p, side){ for(let i=0;i<p.trail.length;i++){ const t=p.trail[i]; const a=(1-i/p.trail.length)*0.2; rr((side==='L'?26:W-26-PW), t.y-PH/2, PW, PH, 6, `rgba(255,255,255,${a})`); } }
function bounce(isLeft,py){
  const off=clamp((S.ball.y-py)/(PH/2),-1,1);
  const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_HIT);
  const ang=off*ANG_MAX, dir=isLeft?1:-1;
  S.ball.vx=dir*sp*Math.cos(ang); S.ball.vy=sp*Math.sin(ang);
  S.ball.x+=dir*(PW/2+BR+2); S.ball.y+=(Math.random()*4-2);
  screenShake(8*Math.min(1,sp/B_MAX)); spawnHitSpark(S.ball.x - dir*8, S.ball.y, dir);
  for(let i=0;i<6;i++) S.trail.unshift({x:S.ball.x - dir*i*4, y:S.ball.y+(Math.random()*6-3), heat:1, r:BR+(i%2)});
  if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX;
}
function resetRound(){
  S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  S.L.forEach(p=>{p.y=H/2; p.trail.length=0;}); S.R.forEach(p=>{p.y=H/2; p.trail.length=0;});
  S.ball.x=W/2; S.ball.y=H/2; const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1);
  S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);
}

/* ====== 렌더 ====== */
function drawFlameTrail(){
  const sp=speed(S.ball), heat=clamp((sp-B_INIT)/(B_MAX-B_INIT),0,1), trailLen=Math.floor(6+heat*30);
  S.trail.unshift({x:S.ball.x,y:S.ball.y,heat,r:BR}); if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX;
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for(let i=0;i<Math.min(trailLen,S.trail.length); i++){
    const p=S.trail[i], t=i/trailLen, a=(1-t)*(0.12+0.55*heat), r=p.r*(1+0.9*(1-t)*(0.25+0.75*heat));
    const grad=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r*2.2);
    grad.addColorStop(0,`rgba(255,70,30,${a*0.7})`); grad.addColorStop(1,`rgba(255,160,60,${a*0.22})`);
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(p.x,p.y,r*2.2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=`rgba(255,210,80,${a})`; ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(2,r*0.6),0,Math.PI*2); ctx.fill();
  }
  const a0=0.24+0.5*heat, r0=BR*(2.4+2.2*heat), g0=ctx.createRadialGradient(S.ball.x,S.ball.y,0,S.ball.x,S.ball.y,r0);
  g0.addColorStop(0,`rgba(255,220,100,${a0})`); g0.addColorStop(1,`rgba(255,120,40,0)`); ctx.fillStyle=g0;
  ctx.beginPath(); ctx.arc(S.ball.x,S.ball.y,r0,0,Math.PI*2); ctx.fill(); ctx.restore();
}
function drawScore(){
  ctx.fillStyle='#DCE6FF'; ctx.font='bold 28px Inter,system-ui';
  ctx.textAlign='right'; ctx.fillText(String(S.sL), W*0.5-60,40); ctx.textAlign='left'; ctx.fillText(String(S.sR), W*0.5+60,40);
}
function drawAll(dt){
  let ox=0,oy=0; if(S.shake>0){ ox=(Math.random()*2-1)*S.shake; oy=(Math.random()*2-1)*S.shake; S.shake*=0.85; if(S.shake<0.2)S.shake=0; }
  ctx.save(); ctx.translate(ox,oy);
  bg(); drawSpeedLines(); drawFlameTrail();
  if(S.L[0]) drawPaddleTrail(S.L[0],'L'); if(S.R[0]) drawPaddleTrail(S.R[0],'R');
  for(const p of S.L) rr(26,p.y-PH/2,PW,PH,6,COLORS.L);
  for(const p of S.R) rr(W-26-PW,p.y-PH/2,PW,PH,6,COLORS.R);
  circle(S.ball.x,S.ball.y,BR,'#101420'); circle(S.ball.x,S.ball.y,BR-2,'#1b2238'); circle(S.ball.x,S.ball.y,BR-3,'#FFC857');
  drawSparks(); drawScore(); ctx.restore();
}

/* ====== 루프 ====== */
let fpsA=0,fpsN=0;
async function loop(now=performance.now()){
  const dt=Math.min(.05,(now-S.last)/1000); S.last=now;
  fpsA+=dt; fpsN++; if(fpsA>=.5){ fpsEl.textContent=Math.round(fpsN/fpsA)+' fps'; fpsA=0; fpsN=0; }

  if(S.scene==='play' && !S.paused){
    if(net.role){ tickNet(dt); } else { await tickLocal(dt); }
    // 타이머
    if(S.run){ S.t=Math.max(0,S.t-dt); timeEl.textContent=fmt(S.t); if(S.t===0){ endMatch(); } }
  }
  drawAll(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== 로컬 tick ====== */
async function tickLocal(dt){
  // 입력/AI
  for(const p of S.L){ let act=1; if(p.aiSide==='L') act=await aiActLeft(p.y,S.R[0]?.y??H/2); apply(p,act); if(Math.random()<.6) pushPaddleTrail('L'); }
  for(const p of S.R){ let act=1; if(p.upKey||p.downKey){ const u=Keys.get(p.upKey), d=Keys.get(p.downKey); act=u&&!d?0:d&&!u?2:1; } else if(p.aiSide==='R'){ act=await aiActRight(p.y,S.L[0]?.y??H/2);} apply(p,act); if(Math.random()<.6) pushPaddleTrail('R'); }
  // 공 이동/충돌
  moveAndCollide(dt);
}

/* ====== 공 이동/충돌 공통 ====== */
function moveAndCollide(dt){
  S.ball.x+=S.ball.vx*dt; S.ball.y+=S.ball.vy*dt;
  if(S.ball.y<=BR){ S.ball.y=BR; S.ball.vy=Math.abs(S.ball.vy); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL); const ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4); spawnSpeedLines(S.ball.vx,S.ball.vy); }
  if(S.ball.y>=H-BR){ S.ball.y=H-BR; S.ball.vy=-Math.abs(S.ball.vy); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL); const ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4); spawnSpeedLines(S.ball.vx,S.ball.vy); }
  if(S.ball.vx<0){ for(const p of S.L){ const L={x:26,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,L.x,L.y,L.w,L.h)){ bounce(true,p.y); break; } } }
  else{ for(const p of S.R){ const R={x:W-26-PW,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,R.x,R.y,R.w,R.h)){ bounce(false,p.y); break; } } }
  let scored=null;
  if(S.ball.x<-BR){ S.sR++; S.rallyRight=true; scored='R'; }
  if(S.ball.x>W+BR){ S.sL++; S.rallyRight=false; scored='L'; }
  if(scored){ screenShake(12); resetRound(); }
}

/* ====== P2P 멀티 (PeerJS) ====== */
const net={
  role:null,   // 'host' | 'guest' | null
  peer:null,   // Peer
  conn:null,   // DataConnection
  code:null,
  smooth:{ oppY:H/2, oppTarget:H/2 }
};
function genCode(){ return String(Math.floor(100000+Math.random()*900000)); }
function setState(t){ netState.textContent=t; }
btnHost.onclick=()=>{ net.role='host'; net.code=genCode(); roomCodeEl.textContent=net.code; setState('호스트 준비'); };
btnJoin.onclick=()=>{ net.role='guest'; roomCodeEl.textContent='— — — — — —'; setState('참여 대기'); };
btnCopy.onclick=()=>{ if(net.code){ navigator.clipboard.writeText(net.code); } };
btnConnect.onclick=()=>{ const nick=nickEl.value.trim()||'YOU'; if(net.role==='host'){ startHost(nick); } else if(net.role==='guest'){ const code=codeInput.value.trim(); if(/^\d{6}$/.test(code)){ startGuest(nick,code); } else { setState('코드 오류'); } } };
btnStartNet.onclick=()=>{ if(net.role==='host' && net.conn && net.conn.open){ startNetMatch(); } };

function startHost(nick){
  try{
    setState('피어 생성…');
    net.peer=new Peer('PONG-'+net.code,{debug:0});
    net.peer.on('open', id=>{ setState('대기 중'); });
    net.peer.on('connection', conn=>{
      net.conn=conn; setState('연결됨'); btnStartNet.disabled=false;
      conn.on('data', onNetData);
      conn.on('close', ()=>{ setState('상대 종료'); btnStartNet.disabled=true; });
      // 역할 공지
      conn.send({t:'hello', side:'R', nick});
    });
  }catch(e){ setState('에러'); }
}
function startGuest(nick, code){
  try{
    setState('연결 중…');
    net.peer=new Peer(undefined,{debug:0});
    net.peer.on('open', id=>{
      const conn=net.peer.connect('PONG-'+code);
      conn.on('open', ()=>{ net.conn=conn; setState('연결됨'); conn.on('data', onNetData); conn.send({t:'hello', side:'R', nick}); });
      conn.on('close', ()=> setState('연결 종료'));
      conn.on('error', ()=> setState('에러'));
    });
  }catch(e){ setState('에러'); }
}
function disconnectNet(){
  if(net.conn){ try{ net.conn.close(); }catch{} }
  if(net.peer){ try{ net.peer.destroy(); }catch{} }
  net.role=null; net.conn=null; net.peer=null; net.code=null; btnStartNet.disabled=true; setState('대기');
}
function startNetMatch(){
  // 호스트가 게임 생성(호스트=Left, 게스트=Right)
  S.sL=0; S.sR=0; S.t=MATCH_SEC; S.paused=false; S.run=true; S.scene='play';
  S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  S.L=[makePaddle('L', COLORS.L, 'KeyW','KeyS', null)]; // 호스트 키: W/S
  S.R=[makePaddle('R', COLORS.R, null,null, null)];     // 게스트는 입력만 전송
  resetRound();
  // 시작 알림
  net.conn.send({t:'start'});
}
function onNetData(msg){
  if(!msg || !msg.t) return;
  if(msg.t==='hello'){ /* no-op */ }
  else if(msg.t==='start'){ // 게스트 수신: 게임 세팅
    S.sL=0; S.sR=0; S.t=MATCH_SEC; S.paused=false; S.run=true; S.scene='play';
    S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
    S.L=[makePaddle('L', COLORS.L, null,null, null)]; // 게스트는 오른쪽 조종, 왼쪽은 화면용
    S.R=[makePaddle('R', COLORS.R, 'ArrowUp','ArrowDown', null)];
    resetRound();
  }
  else if(msg.t==='state'){ // 게스트: 호스트 상태 동기
    const d=msg.d;
    S.ball.x=d.bx; S.ball.y=d.by; S.ball.vx=d.bvx; S.ball.vy=d.bvy;
    S.sL=d.sL; S.sR=d.sR; S.t=d.t; S.rallyRight=d.rr;
    S.L[0].y = d.ly;
    // 상대(게스트가 조작하는 R)는 보간
    net.smooth.oppTarget=d.ry;
  }
  else if(msg.t==='input'){ /* host only receives from guest */ }
}

/* ====== 네트워크 tick ====== */
function tickNet(dt){
  if(net.role==='host'){
    // 호스트: 본인(W/S) + 상대 입력 반영
    // 게스트 입력은 net.remoteAct에 유지
    const left = S.L[0], right = S.R[0];
    // Host local input
    let actL = (Keys.get('KeyW')&&!Keys.get('KeyS'))?0 : (Keys.get('KeyS')&&!Keys.get('KeyW'))?2 : 1;
    apply(left, actL);

    // Guest input은 net.remoteAct (없으면 유지)
    const actR = net.remoteAct ?? 1; apply(right, actR);

    moveAndCollide(dt);

    // 상태 브로드캐스트(20Hz 정도 느낌으로)
    net._acc = (net._acc||0) + dt;
    if(net._acc > 0.05 && net.conn && net.conn.open){
      net._acc = 0;
      net.conn.send({t:'state', d:{
        bx:S.ball.x, by:S.ball.y, bvx:S.ball.vx, bvy:S.ball.vy,
        ly:left.y, ry:right.y, sL:S.sL, sR:S.sR, t:S.t, rr:S.rallyRight
      }});
    }
  }else if(net.role==='guest'){
    // 게스트: 본인(오른쪽) 입력만 전송, 좌/공은 호스트 상태를 수신 반영
    const right=S.R[0]; if(!right) return;
    let act = (Keys.get('ArrowUp')&&!Keys.get('ArrowDown'))?0 : (Keys.get('ArrowDown')&&!Keys.get('ArrowUp'))?2 : 1;
    // 보간 적용
    net.smooth.oppY += (net.smooth.oppTarget - net.smooth.oppY) * 0.35;
    right.y = net.smooth.oppY; // 화면상 우리쪽 패들은 실제론 right지만 호스트가 authoritative
    // 입력 전송(20Hz)
    net._acc = (net._acc||0) + dt;
    if(net._acc>0.05 && net.conn && net.conn.open){ net._acc=0; net.conn.send({t:'input', a:act}); }
  }
}
// 호스트가 게스트 입력 받기
window.addEventListener('message',()=>{});
/* DataConnection on data: 이미 onNetData에서 처리하지만 input은 분리 */
(function hookInput(){
  const _old=onNetData;
  onNetData=function(msg){
    if(msg.t==='input' && net.role==='host'){ net.remoteAct = msg.a; return; }
    _old(msg);
  }
})();

/* ====== 버튼 흐름 ====== */
function endMatch(){ S.run=false; show(postOv,true);
  postInner.innerHTML=`<div style="display:grid;gap:12px;place-items:center">
    <div style="font-size:40px;font-weight:900">경기 종료</div>
    <div style="font-weight:900">${S.sL} : ${S.sR}</div>
    <button class="btn alt" onclick="show(postOv,false); show(modeOv,true);">모드로 돌아가기</button>
  </div>`; }
</script>
</body>
</html>
