<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>PONG — Hyper (Local + Online)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<style>
  :root{
    --bg:#0B1020; --ink:#EAF0FF; --muted:#90A0C0; --line:#1D2540;
    --card:#0E1430; --blue:#5B7CFF; --coral:#FF6E5A;
    --shadow:0 20px 60px rgba(0,10,40,.4);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1600px 900px at 50% -20%, #18224D 0%, #0B1020 55%) fixed; color:var(--ink);
    font-family:Inter,Pretendard,system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif; overflow:hidden}
  .wrap{height:100vh;display:grid;place-items:center;padding:18px}
  .card{height:calc(100vh - 36px);width:min(1100px,96vw);background:linear-gradient(180deg,#0F1638,#0B1020);
    border:1px solid #1a2144;border-radius:18px;box-shadow:var(--shadow);position:relative;padding:14px}
  .top{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .title{font-weight:900;letter-spacing:.28rem;opacity:.9}
  .badge{display:inline-flex;gap:8px;align-items:center;background:#0f1642;border:1px solid var(--line);
    border-radius:10px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%;background:#3a4268}
  .ok{background:#22D07A}.warn{background:#FFB020}
  #gameBox{position:relative;height:calc(100% - 44px)}
  canvas{display:block;width:100%;height:100%;border-radius:14px;box-shadow:inset 0 0 0 1px #1a2144}
  .ctrl{position:absolute;left:12px;right:12px;bottom:10px;display:flex;gap:8px;align-items:center;z-index:4}
  .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;background:#111a3d;color:#fff;
    font-weight:800;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn.alt{background:#2b3fe6} .btn.ghost{background:#0b122e;color:#dfe6ff;border:1px solid #1a2144}
  .overlay{position:absolute;inset:0;border-radius:14px;background:
    radial-gradient(1200px 600px at 50% -40%, rgba(91,124,255,.14), transparent 60%), rgba(12,16,36,.88);
    backdrop-filter:blur(6px) saturate(1.08);display:none;z-index:7}
  .ctr{position:absolute;inset:0;display:grid;place-items:center;padding:16px}
  .modes{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;width:min(820px,96%)}
  .mode{border-radius:14px;padding:16px;background:linear-gradient(180deg,#0f1638,#0c122e);
    border:1px solid #1a2144;cursor:pointer;text-align:center;transition:.2s}
  .mode:hover{box-shadow:0 12px 26px rgba(91,124,255,.25);transform:translateY(-1px)}
  .small{font-size:12px;color:#9eaad0}
  .vignette{position:absolute;inset:0;border-radius:14px;pointer-events:none;box-shadow:inset 0 0 120px rgba(0,0,0,.55)}

  /* 탭 헤더(타이틀 영역) */
  .tabs{display:flex;gap:10px;position:absolute;left:14px;top:14px;z-index:8}
  .tab{padding:8px 14px;border-radius:999px;background:#0b122e;border:1px solid #1a2144;color:#cfd6ff;font-weight:800;cursor:pointer}
  .tab.on{background:#1a2250;color:#fff}

  /* 온라인 패널 */
  .online{margin-top:12px;display:grid;gap:10px;place-items:center}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:center}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#0f1642;border:1px solid #1a2144;border-radius:999px;padding:6px 12px;font-size:12px;color:#cfd6ff}
  .input{background:#0b122e;border:1px solid #1a2144;color:#eaf0ff;border-radius:10px;padding:10px 12px;min-width:220px;font-weight:700}
  .seg{display:inline-flex;background:#0b122e;border:1px solid #1a2144;border-radius:10px;overflow:hidden}
  .seg button{border:0;background:transparent;color:#cfd6ff;padding:8px 12px;font-weight:800;cursor:pointer}
  .seg button.on{background:#1a2250;color:#fff}

  /* 하위 모드 슬라이드 */
  .sub{overflow:hidden;max-height:0;transition:max-height .28s ease; margin-top:8px}
  .sub-inner{display:flex;gap:8px;align-items:center;justify-content:center}
  .chip{padding:10px 14px;border-radius:10px;background:#16205a;color:#fff;border:1px solid #1a2144;cursor:pointer;font-weight:800}
  .chip:hover{background:#21307a}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="top">
      <div class="title">P O N G — HYPER</div>
      <div class="badge"><span id="fps">0 fps</span><span class="dot" id="aiDot"></span><span id="aiTxt">AI: loading…</span></div>
    </div>

    <div id="gameBox">
      <canvas id="cv" width="800" height="600"></canvas>
      <div class="vignette"></div>

      <!-- 타이틀 탭 -->
      <div class="tabs">
        <button id="tabLocal" class="tab on">로컬</button>
        <button id="tabOnline" class="tab">온라인</button>
      </div>

      <!-- Title -->
      <section id="titleOv" class="overlay" style="display:block;">
        <div class="ctr" id="titleCtr"></div>
      </section>

      <!-- Finish -->
      <section id="postOv" class="overlay">
        <div class="ctr" id="postInner"></div>
      </section>

      <!-- Controls -->
      <div class="ctrl">
        <button id="btnTitle" class="btn ghost">타이틀</button>
        <button id="btnReset" class="btn">재시작</button>
        <button id="btnPause" class="btn alt">일시정지</button>
        <div style="margin-left:auto;font-weight:900"><span id="time">–:––</span></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/* =================== 공통(물리/연출/유틸) =================== */
const W=800,H=600,PW=12,PH=88,BR=8;
const PAD_SPEED=480, B_INIT=420, B_MAX=1300, GROW_HIT=1.14, GROW_WALL=1.03, ANG_MAX=(40*Math.PI)/180;
const MATCH_SEC=120;
const COLORS={L:'#5B7CFF', R:'#FF6E5A', T:'#41C9B8', B:'#FFC857'};
const TRAIL_MAX=110;
const cv=document.getElementById('cv'), ctx=cv.getContext('2d'); ctx.imageSmoothingEnabled=true;
const fpsEl=document.getElementById('fps'), aiDot=document.getElementById('aiDot'), aiTxt=document.getElementById('aiTxt');
const titleOv=document.getElementById('titleOv'), titleCtr=document.getElementById('titleCtr');
const postOv=document.getElementById('postOv'), postInner=document.getElementById('postInner');
const timeEl=document.getElementById('time');
const Keys=new Map();
addEventListener('keydown',e=>{ Keys.set(e.code,true); if(e.code==='KeyP')S.paused=!S.paused; if(e.code==='KeyR')resetRound(); });
addEventListener('keyup',e=>Keys.set(e.code,false));

const S={
  scene:'title', mode:'local', subMode:'aiai', variant:'duel', paused:false, last:performance.now(), run:false,
  ball:{x:W/2,y:H/2,vx:B_INIT,vy:0},
  sL:0,sR:0,rallyRight:Math.random()<.5,t:MATCH_SEC,
  L:[],R:[],T:[],B:[], trail:[], speedLines:[], shake:0, scorePop:null,
  net:{active:false, isHost:false, mySide:'L', otherSide:'R', conn:null, peer:null, roomCode:null, syncing:false}
};

/* QUAD arena */
const QUAD={size:520, padLong:110, padThick:12, marginX:0, marginY:0};
function layoutQuad(){
  const s=Math.floor(Math.min(W,H)*0.8);  // 확실한 정사각형
  QUAD.size=s; QUAD.padLong=Math.floor(s*0.2); QUAD.padThick=12;
  QUAD.marginX=Math.floor((W-s)/2); QUAD.marginY=Math.floor((H-s)/2);
}
function show(el,on){ el.style.display=on?'block':'none'; }
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function rr(x,y,w,h,r,c){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fillStyle=c; ctx.fill(); }
function circle(x,y,r,c){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); ctx.fillStyle=c; ctx.fill(); }
function bg(){ ctx.clearRect(0,0,W,H); const g=ctx.createLinearGradient(0,0,W,H); g.addColorStop(0,'#0D1434'); g.addColorStop(1,'#0A0F25'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  if(S.variant==='duel'){ ctx.fillStyle='rgba(90,110,170,.45)'; for(let y=0;y<H;y+=26) ctx.fillRect(W/2-2,y,4,13); } }
function fmt(t){ const m=Math.floor(t/60), s=Math.floor(t%60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }
function speed(b){ return Math.hypot(b.vx,b.vy); }
function setSpeedDir(b, sp, ang){ b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; }
function screenShake(p){ S.shake=Math.max(S.shake,p); }
function applyV(p,act,min=PH/2,max=H-PH/2){ const d=(act===0?-1:(act===2?1:0))*PAD_SPEED*(1/60); p.y=clamp(p.y+d,min,max); }
function applyH(p,act,min,max){ const d=(act===0?-1:(act===2?1:0))*PAD_SPEED*(1/60); p.x=clamp((p.x||W/2)+d,min,max); }
function circleRect(cx,cy,cr,rx,ry,rw,rh){ const nx=clamp(cx,rx,rx+rw), ny=clamp(cy,ry,ry+rh); const dx=cx-nx,dy=cy-ny; return dx*dx+dy*dy<=cr*cr; }

/* 이펙트(불꽃/스파크/스피드라인) */
function pushPaddleTrail(side){
  let arr, ref;
  if(side==='L'){arr=S.L[0]?.trail; ref=S.L[0];}
  if(side==='R'){arr=S.R[0]?.trail; ref=S.R[0];}
  if(side==='T'){arr=S.T[0]?.trail; ref=S.T[0];}
  if(side==='B'){arr=S.B[0]?.trail; ref=S.B[0];}
  if(!arr||!ref) return;
  const obj = (side==='T'||side==='B')?{x:ref.x,a:1}:{y:ref.y,a:1};
  arr.unshift(obj); if(arr.length>12) arr.length=12;
}
function drawPaddleTrail(p, side){
  for(let i=0;i<p.trail.length;i++){
    const t=p.trail[i]; const a=(1 - i/p.trail.length)*0.25;
    ctx.fillStyle=`rgba(255,255,255,${a*0.08})`;
    if(side==='L') rr(26, (t.y??p.y)-PH/2, PW, PH, 6, ctx.fillStyle);
    else if(side==='R') rr(W-26-PW, (t.y??p.y)-PH/2, PW, PH, 6, ctx.fillStyle);
    else if(side==='T'){ const x=(t.x??p.x)-QUAD.padLong/2, y=QUAD.marginY-QUAD.padThick; rr(x,y,QUAD.padLong,QUAD.padThick,6,ctx.fillStyle); }
    else if(side==='B'){ const x=(t.x??p.x)-QUAD.padLong/2, y=QUAD.marginY+QUAD.size; rr(x,y,QUAD.padLong,QUAD.padThick,6,ctx.fillStyle); }
  }
}
const sparks=[];
function spawnHitSpark(x,y,dir){ for(let i=0;i<10;i++){ const ang=(Math.random()*0.9-0.45)+(dir>0?0:Math.PI); const spd=220+Math.random()*420; sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:.25,age:0}); } }
function updateSparks(dt){ for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.age+=dt; s.x+=s.vx*dt; s.y+=s.vy*dt; s.vx*=0.96; s.vy*=0.96; if(s.age>=s.life) sparks.splice(i,1); } }
function drawSparks(){ ctx.save(); ctx.globalCompositeOperation='lighter'; for(const s of sparks){ const t=1-s.age/s.life; ctx.fillStyle=`rgba(255,180,80,${0.6*t})`; ctx.beginPath(); ctx.arc(s.x,s.y,2+3*t,0,Math.PI*2); ctx.fill(); } ctx.restore(); }
function spawnSpeedLines(vx,vy){ const sp=Math.hypot(vx,vy), n=Math.floor(clamp((sp-520)/75,0,12)); for(let i=0;i<n;i++){ const ang=Math.atan2(vy,vx)+(Math.random()*0.4-0.2); const len=30+Math.random()*90; const x=S.ball.x - Math.cos(ang)*8, y=S.ball.y - Math.sin(ang)*8; S.speedLines.push({x,y,ang,len,age:0,life:.18}); } if(S.speedLines.length>70) S.speedLines.splice(0,S.speedLines.length-70); }
function updateSpeedLines(dt){ for(let i=S.speedLines.length-1;i>=0;i--){ const l=S.speedLines[i]; l.age+=dt; l.x-=Math.cos(l.ang)*S.ball.vx*dt*0.2; l.y-=Math.sin(l.ang)*S.ball.vy*dt*0.2; if(l.age>=l.life) S.speedLines.splice(i,1); } }
function drawSpeedLines(){ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(120,180,255,.45)'; ctx.lineWidth=2; for(const l of S.speedLines){ const t=1-l.age/l.life, dx=Math.cos(l.ang)*l.len*t, dy=Math.sin(l.ang)*l.len*t; ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(l.x-dx,l.y-dy); ctx.stroke(); } ctx.restore(); }
function drawFlameTrail(){ const sp=speed(S.ball), heat=clamp((sp-B_INIT)/(B_MAX-B_INIT),0,1); const trailLen=Math.floor(6+heat*32); S.trail.unshift({x:S.ball.x,y:S.ball.y,heat,r:BR}); if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX; ctx.save(); ctx.globalCompositeOperation='lighter'; for(let i=0;i<Math.min(trailLen,S.trail.length); i++){ const p=S.trail[i], t=i/trailLen, a=(1-t)*(0.13+0.58*heat), r=p.r*(1+0.95*(1-t)*(0.3+0.7*heat)); const grad=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r*2.2); grad.addColorStop(0,`rgba(255,70,30,${a*0.7})`); grad.addColorStop(1,`rgba(255,160,60,${a*0.22})`); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(p.x,p.y,r*2.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle=`rgba(255,210,80,${a})`; ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(2,r*0.6),0,Math.PI*2); ctx.fill(); } const a0=0.26+0.5*heat, r0=BR*(2.5+2.3*heat); const g0=ctx.createRadialGradient(S.ball.x,S.ball.y,0,S.ball.x,S.ball.y,r0); g0.addColorStop(0,`rgba(255,220,100,${a0})`); g0.addColorStop(1,`rgba(255,120,40,0)`); ctx.fillStyle=g0; ctx.beginPath(); ctx.arc(S.ball.x,S.ball.y,r0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
function spawnScorePop(text){ S.scorePop={text,age:0,life:.9}; }
function drawScorePop(dt){ if(!S.scorePop)return; const p=S.scorePop; p.age+=dt; const t=Math.min(1,p.age/p.life), y=H*0.3-30*t, a=(1-t); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#EAF0FF'; ctx.font='900 44px Inter,system-ui'; ctx.textAlign='center'; ctx.fillText(p.text,W/2,y); ctx.restore(); if(p.age>=p.life) S.scorePop=null; }

/* ======= AI ======= */
let ortSession=null, aiReady=false;
(async()=>{ try{ aiTxt.textContent='AI: loading…'; aiDot.className='dot'; ortSession=await ort.InferenceSession.create('model.onnx',{executionProviders:['wasm']}); aiReady=true; aiTxt.textContent='AI: loaded'; aiDot.className='dot ok'; }catch{ aiReady=false; aiTxt.textContent='AI: failed (heuristic)'; aiDot.className='dot warn'; }})();
function obsLeft(py,oy){ const bx=(S.ball.x/W)*2-1, by=(S.ball.y/H)*2-1, bvx=clamp(S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1), p=(py/H)*2-1,o=(oy/H)*2-1, rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1); return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);}
function obsRightMirror(py,oy){ const bx=((W-S.ball.x)/W)*2-1, by=(S.ball.y/H)*2-1, bvx=clamp(-S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1), p=(py/H)*2-1,o=(oy/H)*2-1, rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1); return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);}
async function aiActLeft(py,oy){ if(!aiReady||!ortSession) return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; try{ const out=await ortSession.run({observation:obsLeft(py,oy)}); const k=Object.keys(out)[0]; return ((out[k].data||out[k])[0]|0);}catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; } }
async function aiActRight(py,oy){ if(!aiReady||!ortSession) return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; try{ const out=await ortSession.run({observation:obsRightMirror(py,oy)}); const k=Object.keys(out)[0]; return ((out[k].data||out[k])[0]|0);}catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; } }

/* ======= 타이틀 UI (로컬/온라인) ======= */
const tabLocal=document.getElementById('tabLocal'), tabOnline=document.getElementById('tabOnline');
function renderLocalTitle(){
  titleCtr.innerHTML=`
    <div style="display:grid;gap:18px;place-items:center">
      <h1 style="margin:0;font-size:54px;letter-spacing:.5rem">로컬 모드</h1>
      <div class="modes">
        <div class="mode" id="mAIAI"><h3>AI vs AI</h3><div class="small">둘 다 AI</div></div>
        <div class="mode" id="mAIP"><h3>AI vs PLAYER</h3><div class="small">오른쪽: ↑/↓ 또는 W/S</div></div>
        <div class="mode" id="mPVP"><h3>PLAYER vs PLAYER</h3><div class="small">왼쪽: W/S · 오른쪽: ↑/↓</div></div>
      </div>
      <div class="sub" id="subLocal"><div class="sub-inner">
        <div class="chip" data-var="duel">1대1</div>
        <div class="chip" data-var="quad">쿼드라퐁(정사각 4인)</div>
      </div></div>
      <div class="small">일시정지 P · 재시작 R</div>
    </div>`;
  const sub=document.getElementById('subLocal');
  ['mAIAI','mAIP','mPVP'].forEach(id=>{
    document.getElementById(id).onclick=()=>{ sub.style.maxHeight=sub.style.maxHeight==='120px'?'0px':'120px'; S.subMode=id==='mAIAI'?'aiai':id==='mAIP'?'aip':'pvp'; };
  });
  sub.addEventListener('click',e=>{
    if(!e.target.classList.contains('chip'))return;
    S.variant=e.target.dataset.var; startLocal();
  });
}
function renderOnlineTitle(){
  titleCtr.innerHTML=`
    <div style="display:grid;gap:12px;place-items:center" class="online">
      <h1 style="margin:0 0 6px;font-size:54px;letter-spacing:.5rem">온라인 모드</h1>
      <div class="row">
        <div class="seg">
          <button id="oHost" class="on">호스트</button>
          <button id="oJoin">참여</button>
        </div>
        <div id="netBadge" class="pill">대기</div>
      </div>
      <div id="onlineHost" class="row">
        <input id="hostName" class="input" placeholder="내 닉네임" maxlength="16" style="min-width:150px"/>
        <button id="btnHostGo" class="btn alt">코드 생성</button>
        <div id="hostInfo" class="pill" style="display:none">상태: 대기</div>
        <div id="hostCode" class="pill" style="display:none">코드: ——</div>
        <button id="btnCopy" class="btn ghost" style="display:none">코드 복사</button>
        <button id="btnStart" class="btn" disabled>게임 시작</button>
      </div>
      <div id="onlineJoin" class="row" style="display:none">
        <input id="joinName" class="input" placeholder="내 닉네임" maxlength="16" style="min-width:150px"/>
        <input id="joinCode" class="input" placeholder="참여용 6자리 코드" maxlength="6"/>
        <button id="btnJoinGo" class="btn alt">연결</button>
        <div id="joinInfo" class="pill">상태: 대기</div>
      </div>
      <div class="small">온라인은 1대1 전용(듀얼). 호스트/게스트 중 <b>무작위 사이드</b> 배정.</div>
    </div>`;
  wireOnlineUI();
}
function refreshTitle(){ if(S.mode==='local'){ tabLocal.classList.add('on'); tabOnline.classList.remove('on'); renderLocalTitle(); } else { tabOnline.classList.add('on'); tabLocal.classList.remove('on'); renderOnlineTitle(); } }
tabLocal.onclick=()=>{ S.mode='local'; refreshTitle(); };
tabOnline.onclick=()=>{ S.mode='online'; refreshTitle(); };
refreshTitle();

/* ======= 로컬 모드 시작 ======= */
function makePaddle(side,color,up,down,ai){ return {x:0,y:H/2,color,upKey:up,downKey:down,aiSide:ai,trail:[],isHuman:!ai}; }
function startLocal(){
  // 공통 초기화
  S.sL=0; S.sR=0; S.t=MATCH_SEC; S.paused=false; S.run=true; S.scene='play'; S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  S.ball.x=W/2; S.ball.y=H/2; const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1); S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);
  S.L=[]; S.R=[]; S.T=[]; S.B=[]; S.net.active=false;

  if(S.variant==='duel'){
    if(S.subMode==='aiai'){
      S.L.push(makePaddle('L',COLORS.L,null,null,'L'));
      S.R.push(makePaddle('R',COLORS.R,null,null,'R'));
    }else if(S.subMode==='aip'){
      S.L.push(makePaddle('L',COLORS.L,null,null,'L'));
      const p=makePaddle('R',COLORS.R,'ArrowUp','ArrowDown',null); p.upKey2='KeyW'; p.downKey2='KeyS'; S.R.push(p);
    }else{ // pvp
      S.L.push(makePaddle('L',COLORS.L,'KeyW','KeyS',null));
      S.R.push(makePaddle('R',COLORS.R,'ArrowUp','ArrowDown',null));
    }
  }else{ // QUAD — 정사각형
    layoutQuad();
    // 좌/우 vertical
    const Lp=makePaddle('L',COLORS.L, S.subMode==='pvp'?'KeyW':null, S.subMode==='pvp'?'KeyS':null, S.subMode==='aiai'?'L':(S.subMode==='aip'?'L':null)); Lp.y=H/2;
    const Rp=makePaddle('R',COLORS.R, 'ArrowUp','ArrowDown', S.subMode==='aiai'?'R':(S.subMode==='aip'?null:null)); Rp.y=H/2;
    // 상/하 horizontal(키 없음, AI만)
    const Tp={x:W/2,y:QUAD.marginY+QUAD.padThick/2,color:COLORS.T,trail:[],aiSide:'T'};
    const Bp={x:W/2,y:QUAD.marginY+QUAD.size-QUAD.padThick/2,color:COLORS.B,trail:[],aiSide:'B'};
    S.L.push(Lp); S.R.push(Rp); S.T.push(Tp); S.B.push(Bp);
  }
  show(titleOv,false);
}

/* ======= 충돌/반사 ======= */
function bounceLR(isLeft, py){
  const off=clamp((S.ball.y-py)/(PH/2),-1,1); const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_HIT);
  const ang=off*ANG_MAX, dir=isLeft?1:-1; S.ball.vx=dir*sp*Math.cos(ang); S.ball.vy=sp*Math.sin(ang);
  S.ball.x+=dir*(PW/2+BR+2); S.ball.y+=(Math.random()*4-2); screenShake(8*Math.min(1, sp/B_MAX));
  spawnHitSpark(S.ball.x-dir*8,S.ball.y,dir); pushPaddleTrail(isLeft?'L':'R');
  for(let i=0;i<6;i++) S.trail.unshift({x:S.ball.x - dir*i*4, y:S.ball.y+(Math.random()*6-3), heat:1, r:BR+(i%2)});
  if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX;
}
function bounceTB(isTop, px){
  const off=clamp((S.ball.x - px)/(QUAD.padLong/2), -1, 1); const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_HIT);
  const base=isTop?Math.PI/2:-Math.PI/2; const ang=base + off*ANG_MAX; setSpeedDir(S.ball, sp, ang);
  S.ball.y += (isTop?1:-1)*(QUAD.padThick/2 + BR + 2); S.ball.x += (Math.random()*4-2);
  screenShake(8*Math.min(1, sp/B_MAX)); spawnHitSpark(S.ball.x, S.ball.y+(isTop?8:-8), isTop?1:-1);
}

/* ======= 게임 루프 ======= */
let fpsA=0,fpsN=0;
async function gameLoop(now=performance.now()){
  const dt=Math.min(.05,(now-S.last)/1000); S.last=now;
  fpsA+=dt; fpsN++; if(fpsA>=.5){ fpsEl.textContent=Math.round(fpsN/fpsA)+' fps'; fpsA=0; fpsN=0; }

  if(S.scene==='play' && !S.paused){
    if(!S.net.active || S.net.isHost){   // 로컬 or 호스트에서만 시뮬레이트(게스트는 스냅샷 적용)
      if(S.variant==='duel'){
        if(S.L[0]){ let act=1; if(S.subMode==='aiai'||(S.mode==='online' && S.net.active && S.net.mySide!=='L')) act=await aiActLeft(S.L[0].y, S.R[0]?.y??H/2);
          else if(S.subMode==='pvp'||S.subMode==='aip'){ const u=Keys.get('KeyW'), d=Keys.get('KeyS'); act=u&&!d?0:d&&!u?2:1; } applyV(S.L[0], act); if(Math.random()<.6) pushPaddleTrail('L'); }
        if(S.R[0]){ let act=1;
          if(S.mode==='online' && S.net.active){ // 온라인: 각자 자신의 사이드만 현지 입력
            if(S.net.mySide==='R'){ const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false; const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false; act=up&&!dn?0:dn&&!up?2:1; }
            else act=await aiActRight(S.R[0].y, S.L[0]?.y??H/2); // 호스트가 L일 땐 R을 게스트 입력으로 덮어씀(아래에서)
          }else{
            if(S.subMode==='aiai') act=await aiActRight(S.R[0].y, S.L[0]?.y??H/2);
            else if(S.subMode==='aip'||S.subMode==='pvp'){ const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false; const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false; act=up&&!dn?0:dn&&!up?2:1; }
          }
          applyV(S.R[0], act); if(Math.random()<.6) pushPaddleTrail('R'); }

        // 이동
        S.ball.x+=S.ball.vx*dt; S.ball.y+=S.ball.vy*dt;
        if(S.ball.y<=BR||S.ball.y>=H-BR){ S.ball.y=S.ball.y<=BR?BR:H-BR; S.ball.vy=S.ball.y===BR?Math.abs(S.ball.vy):-Math.abs(S.ball.vy);
          const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4); spawnSpeedLines(S.ball.vx,S.ball.vy); }
        if(S.ball.vx<0){ const p=S.L[0]; if(p){ const r={x:26,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,r.x,r.y,r.w,r.h)) bounceLR(true,p.y); }}
        else{ const p=S.R[0]; if(p){ const r={x:W-26-PW,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,r.x,r.y,r.w,r.h)) bounceLR(false,p.y); }}
        let scored=null; if(S.ball.x<-BR){S.sR++; S.rallyRight=true; scored='RIGHT'; } if(S.ball.x>W+BR){S.sL++; S.rallyRight=false; scored='LEFT';}
        if(scored){ spawnScorePop(scored==='LEFT'?'LEFT +1':'RIGHT +1'); screenShake(12); resetRound(); }

      }else{ // QUAD
        const minY=QUAD.marginY+QUAD.padLong/2,maxY=QUAD.marginY+QUAD.size-QUAD.padLong/2;
        if(S.L[0]){ let act=1; if(S.subMode!=='pvp') act=(S.ball.y<S.L[0].y-4)?0:(S.ball.y>S.L[0].y+4)?2:1; else { const u=Keys.get('KeyW'),d=Keys.get('KeyS'); act=u&&!d?0:d&&!u?2:1; } applyV(S.L[0], act, minY, maxY); if(Math.random()<.6) pushPaddleTrail('L'); }
        if(S.R[0]){ let act=1; if(S.subMode==='aiai') act=(S.ball.y<S.R[0].y-4)?0:(S.ball.y>S.R[0].y+4)?2:1; else { const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false; const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false; act=up&&!dn?0:dn&&!up?2:1; } applyV(S.R[0], act, minY, maxY); if(Math.random()<.6) pushPaddleTrail('R'); }
        if(S.T[0]){ let act=(S.ball.x<S.T[0].x-4)?0:(S.ball.x>S.T[0].x+4)?2:1; applyH(S.T[0],act, QUAD.marginX+QUAD.padLong/2, QUAD.marginX+QUAD.size-QUAD.padLong/2); if(Math.random()<.6) pushPaddleTrail('T'); }
        if(S.B[0]){ let act=(S.ball.x<S.B[0].x-4)?0:(S.ball.x>S.B[0].x+4)?2:1; applyH(S.B[0],act, QUAD.marginX+QUAD.padLong/2, QUAD.marginX+QUAD.size-QUAD.padLong/2); if(Math.random()<.6) pushPaddleTrail('B'); }

        S.ball.x+=S.ball.vx*dt; S.ball.y+=S.ball.vy*dt;
        // 좌/우
        if(S.ball.x<=QUAD.marginX+BR){ const p=S.L[0]; const rx=QUAD.marginX-QUAD.padThick,ry=p.y-QUAD.padLong/2,rw=QUAD.padThick,rh=QUAD.padLong;
          if(circleRect(S.ball.x,S.ball.y,BR,rx,ry,rw,rh)) bounceLR(true,p.y); else { S.ball.x=QUAD.marginX+BR; S.ball.vx=Math.abs(S.ball.vx); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL),ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4);} }
        if(S.ball.x>=QUAD.marginX+QUAD.size-BR){ const p=S.R[0]; const rx=QUAD.marginX+QUAD.size,ry=p.y-QUAD.padLong/2,rw=QUAD.padThick,rh=QUAD.padLong;
          if(circleRect(S.ball.x,S.ball.y,BR,rx,ry,rw,rh)) bounceLR(false,p.y); else { S.ball.x=QUAD.marginX+QUAD.size-BR; S.ball.vx=-Math.abs(S.ball.vx); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL),ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4);} }
        // 상/하
        if(S.ball.y<=QUAD.marginY+BR){ const p=S.T[0]; const rx=p.x-QUAD.padLong/2,ry=QUAD.marginY-QUAD.padThick,rw=QUAD.padLong,rh=QUAD.padThick;
          if(circleRect(S.ball.x,S.ball.y,BR,rx,ry,rw,rh)) bounceTB(true,p.x); else { S.ball.y=QUAD.marginY+BR; S.ball.vy=Math.abs(S.ball.vy); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL),ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4);} }
        if(S.ball.y>=QUAD.marginY+QUAD.size-BR){ const p=S.B[0]; const rx=p.x-QUAD.padLong/2,ry=QUAD.marginY+QUAD.size,rw=QUAD.padLong,rh=QUAD.padThick;
          if(circleRect(S.ball.x,S.ball.y,BR,rx,ry,rw,rh)) bounceTB(false,p.x); else { S.ball.y=QUAD.marginY+QUAD.size-BR; S.ball.vy=-Math.abs(S.ball.vy); const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL),ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang); screenShake(4);} }
        // 득점(좌/우)
        let scored=null; if(S.ball.x<QUAD.marginX-BR){S.sR++; S.rallyRight=true; scored='RIGHT';}
        if(S.ball.x>QUAD.marginX+QUAD.size+BR){S.sL++; S.rallyRight=false; scored='LEFT';}
        if(scored){ spawnScorePop(scored==='LEFT'?'LEFT +1':'RIGHT +1'); screenShake(12); resetRound(); }
      }

      // 온라인: 호스트가 스냅샷 브로드캐스트
      if(S.net.active && S.net.isHost && S.net.conn && S.net.conn.open){
        if(!S.net._tick || now-S.net._tick>33){ // ~30Hz
          S.net._tick=now;
          try{ S.net.conn.send({type:'snap', s:{ball:S.ball, L:S.L[0]?.y, R:S.R[0]?.y, sL:S.sL, sR:S.sR, t:S.t}}); }catch{}
        }
      }
    } // host sim end

    // 게스트는 입력만 송신(호스트가 적용)
    if(S.net.active && !S.net.isHost && S.net.conn && S.net.conn.open){
      if(!S.net._itick || now-S.net._itick>50){ S.net._itick=now;
        const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false, dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false;
        const act=up&&!dn?0:dn&&!up?2:1;
        try{ S.net.conn.send({type:'input', act}); }catch{}
      }
    }

    spawnSpeedLines(S.ball.vx,S.ball.vy); updateSparks(dt); updateSpeedLines(dt);
    if(S.run){ S.t=Math.max(0,S.t-dt); timeEl.textContent=fmt(S.t); if(S.t===0) endMatch(); }
  }

  drawFrame(dt);
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* ======= 그리기 ======= */
function drawArenaQuad(){ ctx.strokeStyle='rgba(140,160,220,.28)'; ctx.lineWidth=2; ctx.strokeRect(QUAD.marginX,QUAD.marginY,QUAD.size,QUAD.size); }
function drawFrame(dt){
  let ox=0,oy=0; if(S.shake>0){ ox=(Math.random()*2-1)*S.shake; oy=(Math.random()*2-1)*S.shake; S.shake*=0.85; if(S.shake<0.2)S.shake=0; }
  ctx.save(); ctx.translate(ox,oy); bg(); if(S.variant==='quad') drawArenaQuad();
  drawSpeedLines(); drawFlameTrail();
  // 잔상
  if(S.L[0]) drawPaddleTrail(S.L[0],'L'); if(S.R[0]) drawPaddleTrail(S.R[0],'R');
  if(S.variant==='quad'){ if(S.T[0]) drawPaddleTrail(S.T[0],'T'); if(S.B[0]) drawPaddleTrail(S.B[0],'B'); }
  // 패들
  if(S.variant==='duel'){
    if(S.L[0]) rr(26, S.L[0].y-PH/2, PW, PH, 6, COLORS.L);
    if(S.R[0]) rr(W-26-PW, S.R[0].y-PH/2, PW, PH, 6, COLORS.R);
  }else{
    if(S.L[0]) rr(QUAD.marginX-QUAD.padThick, S.L[0].y-QUAD.padLong/2, QUAD.padThick, QUAD.padLong, 6, COLORS.L);
    if(S.R[0]) rr(QUAD.marginX+QUAD.size, S.R[0].y-QUAD.padLong/2, QUAD.padThick, QUAD.padLong, 6, COLORS.R);
    if(S.T[0]) rr(S.T[0].x-QUAD.padLong/2, QUAD.marginY-QUAD.padThick, QUAD.padLong, QUAD.padThick, 6, COLORS.T);
    if(S.B[0]) rr(S.B[0].x-QUAD.padLong/2, QUAD.marginY+QUAD.size, QUAD.padLong, QUAD.padThick, 6, COLORS.B);
  }
  // 공
  circle(S.ball.x,S.ball.y,BR,'#101420'); circle(S.ball.x,S.ball.y,BR-2,'#1b2238'); circle(S.ball.x,S.ball.y,BR-3,'#FFC857');
  drawSparks();
  // 스코어
  ctx.fillStyle='#DCE6FF'; ctx.font='bold 28px Inter,system-ui';
  ctx.textAlign='right'; ctx.fillText(String(S.sL), W*0.5-60,40);
  ctx.textAlign='left'; ctx.fillText(String(S.sR), W*0.5+60,40);
  ctx.restore(); drawScorePop(dt);
}

/* ======= 라운드/끝 ======= */
function resetRound(){ S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  if(S.variant==='duel'){ S.L.forEach(p=>p.y=H/2); S.R.forEach(p=>p.y=H/2); } else { layoutQuad(); S.L[0].y=H/2; S.R[0].y=H/2; S.T[0].x=W/2; S.B[0].x=W/2; }
  S.ball.x=W/2; S.ball.y=H/2; const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1); S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);
}
function endMatch(){ S.run=false; show(postOv,true);
  postInner.innerHTML=`<div style="display:grid;gap:12px;place-items:center">
    <div style="font-size:40px;font-weight:900">경기 종료</div>
    <div style="font-weight:900">${S.sL} : ${S.sR}</div>
    <button class="btn alt" onclick="show(postOv,false); show(titleOv,true); S.scene='title'; refreshTitle();">타이틀로</button>
  </div>`;}

/* =================== 온라인 (P2P, 단일 경기/랜덤 사이드) =================== */
const ICE=[{urls:'stun:stun.l.google.com:19302'},
  {urls:'turn:openrelay.metered.ca:80',username:'openrelayproject',credential:'openrelayproject'},
  {urls:'turn:openrelay.metered.ca:443',username:'openrelayproject',credential:'openrelayproject'},
  {urls:'turn:openrelay.metered.ca:443?transport=tcp',username:'openrelayproject',credential:'openrelayproject'}];
const PEER_OPT={host:'0.peerjs.com', port:443, secure:true, path:'/', debug:1, config:{iceServers:ICE}};

function wireOnlineUI(){
  const oHost=document.getElementById('oHost'), oJoin=document.getElementById('oJoin');
  const onlineHost=document.getElementById('onlineHost'), onlineJoin=document.getElementById('onlineJoin');
  const netBadge=document.getElementById('netBadge');
  const hostName=document.getElementById('hostName'), joinName=document.getElementById('joinName');
  const btnHostGo=document.getElementById('btnHostGo'), hostInfo=document.getElementById('hostInfo'), hostCode=document.getElementById('hostCode'), btnCopy=document.getElementById('btnCopy'), btnStart=document.getElementById('btnStart');
  const btnJoinGo=document.getElementById('btnJoinGo'), joinCode=document.getElementById('joinCode'), joinInfo=document.getElementById('joinInfo');

  function setBadge(t){ netBadge.textContent=t; }
  function makeCode(){ return String(Math.floor(100000+Math.random()*900000)); }
  let connecting=false;

  oHost.onclick=()=>{ oHost.classList.add('on'); oJoin.classList.remove('on'); onlineHost.style.display='flex'; onlineJoin.style.display='none'; };
  oJoin.onclick=()=>{ oJoin.classList.add('on'); oHost.classList.remove('on'); onlineHost.style.display='none'; onlineJoin.style.display='flex'; };

  // HOST
  btnHostGo.onclick=async()=>{
    if(connecting) return; connecting=true; btnHostGo.disabled=true;
    try{
      const code=makeCode();
      const peer=new Peer(`PONG-${code}`, PEER_OPT); S.net.peer=peer; S.net.roomCode=code; S.net.isHost=true; S.net.active=true;
      peer.on('open',()=>{ hostInfo.style.display='inline-flex'; hostCode.style.display='inline-flex'; btnCopy.style.display='inline-block';
        hostInfo.textContent='상태: 대기'; hostCode.textContent=`코드: ${code}`; setBadge('호스트 대기'); });
      peer.on('connection',(conn)=>{
        if(S.net.conn) return; // 중복 연결 방지
        S.net.conn=conn; conn.on('open',()=>{ setBadge('게스트 연결됨'); hostInfo.textContent='상태: 연결 1'; btnStart.disabled=false;
          conn.on('data',(msg)=>{ if(msg?.type==='input'){ S._guestAct=msg.act|0; } if(msg?.type==='ping'){ try{conn.send({type:'pong'});}catch{} }});
        });
        conn.on('close',()=>{ setBadge('상대 종료'); btnStart.disabled=true; });
      });
      peer.on('error',()=>{ setBadge('오류'); });
      btnCopy.onclick=()=>{ navigator.clipboard.writeText(code); btnCopy.textContent='복사됨'; setTimeout(()=>btnCopy.textContent='코드 복사',900); };

      btnStart.onclick=()=>{
        if(!S.net.conn||!S.net.conn.open) return;
        // 사이드 랜덤 배정
        const sides = Math.random()<.5 ? {host:'L', guest:'R'} : {host:'R', guest:'L'};
        const st={ sL:0,sR:0,rallyRight:Math.random()<.5,t:MATCH_SEC, ball:{x:W/2,y:H/2,vx:B_INIT,vy:0}, variant:'duel', mode:'online' };
        try{ S.net.conn.send({type:'start',state:st, assign:sides}); }catch{}
        // 호스트 로컬 세팅
        S.mode='online'; S.subMode='pvp'; S.variant='duel';
        startOnlineAsHost(st, sides.host, (hostName.value||'Host'));
        show(titleOv,false);
      };
    }finally{ connecting=false; btnHostGo.disabled=false; }
  };

  // JOIN
  btnJoinGo.onclick=async()=>{
    if(connecting) return; connecting=true; btnJoinGo.disabled=true;
    try{
      const code=(joinCode.value||'').trim(); if(code.length!==6){ joinInfo.textContent='상태: 코드 확인'; return; }
      const peer=new Peer(`PONG-G-${makeCode()}`, PEER_OPT); S.net.peer=peer; S.net.isHost=false; S.net.active=true;
      peer.on('open',()=>{
        const conn=peer.connect(`PONG-${code}`,{reliable:true}); S.net.conn=conn;
        conn.on('open',()=>{ joinInfo.textContent='상태: 연결됨'; setBadge('호스트 연결됨'); setInterval(()=>{ try{conn.send({type:'ping'});}catch{} },4000); });
        conn.on('data',(msg)=>{
          if(msg?.type==='start'){ S.mode='online'; S.subMode='pvp'; S.variant='duel';
            startOnlineAsGuest(msg.state, msg.assign.guest, (joinName.value||'Guest')); show(titleOv,false); }
          if(msg?.type==='snap'){ applySnapshot(msg.s); }
          if(msg?.type==='pong'){ /* ok */ }
        });
        conn.on('close',()=>{ joinInfo.textContent='상태: 종료'; setBadge('연결 종료'); });
      });
      peer.on('error',()=>{ joinInfo.textContent='상태: 오류'; });
    }finally{ connecting=false; btnJoinGo.disabled=false; }
  };

  function startOnlineAsHost(st, mySide, myName){
    S.net.mySide=mySide; S.net.otherSide= mySide==='L'?'R':'L';
    S.sL=st.sL; S.sR=st.sR; S.rallyRight=st.rallyRight; S.t=st.t; S.ball={...st.ball};
    S.L=[]; S.R=[]; S.T=[]; S.B=[];
    // 듀얼 PvP, 양쪽 모두 Human. 호스트는 자신의 사이드를 현지 입력으로, 상대는 게스트 입력(_guestAct)으로 처리.
    S.L.push({y:H/2,color:COLORS.L,trail:[],isHuman:true});
    S.R.push({y:H/2,color:COLORS.R,trail:[],isHuman:true});
    // 입력 적용은 gameLoop에서: 호스트가 R사이드일 때는 L을 AI가 아닌 자신의 키로, 반대는 게스트 입력 _guestAct 반영.
    show(titleOv,false);
  }
  function startOnlineAsGuest(st, mySide, myName){
    S.net.mySide=mySide; S.net.otherSide=mySide==='L'?'R':'L';
    S.sL=st.sL; S.sR=st.sR; S.rallyRight=st.rallyRight; S.t=st.t; S.ball={...st.ball};
    S.L=[{y:H/2,color:COLORS.L,trail:[],isHuman:false}];
    S.R=[{y:H/2,color:COLORS.R,trail:[],isHuman:false}];
    // 게스트는 시뮬하지 않음. 스냅샷으로 상태 갱신 + 입력만 송신.
    show(titleOv,false);
  }
  function applySnapshot(s){
    if(!s) return;
    S.ball.x=s.ball.x; S.ball.y=s.ball.y; S.ball.vx=s.ball.vx; S.ball.vy=s.ball.vy;
    if(S.L[0]) S.L[0].y=s.L; if(S.R[0]) S.R[0].y=s.R;
    S.sL=s.sL; S.sR=s.sR; S.t=s.t;
  }
}

/* ======= 버튼 ======= */
document.getElementById('btnTitle').onclick=()=>{ S.scene='title'; S.run=false; show(titleOv,true); refreshTitle(); };
document.getElementById('btnReset').onclick=()=> resetRound();
document.getElementById('btnPause').onclick=()=> S.paused=!S.paused;
</script>
</body>
</html>
