<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>PONG — Hyper + P2P</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<style>
  :root{
    --bg:#0B1020; --ink:#EAF0FF; --muted:#90A0C0; --line:#1D2540;
    --card:#0E1430; --blue:#5B7CFF; --coral:#FF6E5A;
    --shadow:0 20px 60px rgba(0,10,40,.4);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1600px 900px at 50% -20%, #18224D 0%, #0B1020 55%) fixed; color:var(--ink);
    font-family:Inter,Pretendard,system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif; overflow:hidden}
  .wrap{height:100vh;display:grid;place-items:center;padding:18px}
  .card{height:calc(100vh - 36px);width:min(1100px,96vw);background:linear-gradient(180deg,#0F1638,#0B1020);
    border:1px solid #1a2144;border-radius:18px;box-shadow:var(--shadow);position:relative;padding:14px}
  .top{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .title{font-weight:900;letter-spacing:.28rem;opacity:.9}
  .badge{display:inline-flex;gap:8px;align-items:center;background:#0f1642;border:1px solid var(--line);
    border-radius:10px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%;background:#3a4268}
  .ok{background:#22D07A}.warn{background:#FFB020}
  #gameBox{position:relative;height:calc(100% - 44px)}
  canvas{display:block;width:100%;height:100%;border-radius:14px;box-shadow:inset 0 0 0 1px #1a2144}
  .ctrl{position:absolute;left:12px;right:12px;bottom:10px;display:flex;gap:8px;align-items:center;z-index:4}
  .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;background:#111a3d;color:#fff;
    font-weight:800;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,.25)}
  .btn.alt{background:#2b3fe6} .btn.ghost{background:#0b122e;color:#dfe6ff;border:1px solid #1a2144}
  .overlay{position:absolute;inset:0;border-radius:14px;background:
    radial-gradient(1200px 600px at 50% -40%, rgba(91,124,255,.14), transparent 60%), rgba(12,16,36,.85);
    backdrop-filter:blur(6px) saturate(1.1);display:none;z-index:5}
  .ctr{position:absolute;inset:0;display:grid;place-items:center;padding:16px}
  .modes{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;width:min(720px,92%)}
  .mode{border-radius:14px;padding:16px;background:linear-gradient(180deg,#0f1638,#0c122e);
    border:1px solid #1a2144;cursor:pointer;text-align:center;transition:.2s}
  .mode:hover{box-shadow:0 12px 26px rgba(91,124,255,.25);transform:translateY(-1px)}
  .small{font-size:12px;color:#9eaad0}
  .vignette{position:absolute;inset:0;border-radius:14px;pointer-events:none;box-shadow:inset 0 0 120px rgba(0,0,0,.55)}

  /* Multi panel */
  .multi-wrap{position:absolute;left:12px;right:12px;top:12px;z-index:6}
  .multi-head{display:flex;gap:8px;align-items:center}
  .multi-panel{overflow:hidden;max-height:0;transition:max-height .35s ease; }
  .multi-inner{margin-top:8px;padding:12px;border:1px solid #1a2144;border-radius:12px;background:#0d1334}
  .seg{display:inline-flex;background:#0b122e;border:1px solid #1a2144;border-radius:10px;overflow:hidden}
  .seg button{border:0;background:transparent;color:#cfd6ff;padding:8px 12px;font-weight:800;cursor:pointer}
  .seg button.on{background:#1a2250;color:#fff}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#0f1642;border:1px solid #1a2144;border-radius:999px;padding:6px 12px;font-size:12px;color:#cfd6ff}
  .input{background:#0b122e;border:1px solid #1a2144;color:#eaf0ff;border-radius:10px;padding:10px 12px;min-width:220px;font-weight:700}
  .spacer{flex:1}

  /* ▼ 하위 모드(슬라이드) */
  .sub{overflow:hidden;max-height:0;transition:max-height .28s ease; margin-top:8px}
  .sub-inner{display:flex;gap:8px;align-items:center;justify-content:center}
  .chip{padding:10px 14px;border-radius:10px;background:#16205a;color:#fff;border:1px solid #1a2144;
        cursor:pointer;font-weight:800}
  .chip:hover{background:#21307a}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="top">
      <div class="title">P O N G — HYPER</div>
      <div class="badge"><span id="fps">0 fps</span><span class="dot" id="aiDot"></span><span id="aiTxt">AI: loading…</span></div>
    </div>

    <div id="gameBox">
      <canvas id="cv" width="800" height="600"></canvas>
      <div class="vignette"></div>

      <!-- Multiplayer toggle -->
      <div class="multi-wrap">
        <div class="multi-head">
          <button id="btnMulti" class="btn ghost">멀티</button>
          <div id="netBadge" class="pill">오프라인</div>
          <div class="spacer"></div>
        </div>
        <div id="multiPanel" class="multi-panel">
          <div class="multi-inner">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <div class="seg" role="tablist">
                <button id="tabHost" class="on">호스트</button>
                <button id="tabJoin">참여</button>
              </div>

              <!-- 호스트 UI -->
              <div id="hostUI" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                <button id="btnHostGo" class="btn alt">코드 생성</button>
                <div id="hostInfo" class="pill" style="display:none">상태: 대기</div>
                <div id="hostCode" class="pill" style="display:none">코드: ——</div>
                <button id="btnCopy" class="btn ghost" style="display:none">코드 복사</button>
                <button id="btnStart" class="btn" disabled>게임 시작</button>
              </div>

              <!-- 참여 UI (호스트에서는 숨김) -->
              <div id="joinUI" style="display:none;gap:8px;align-items:center;flex-wrap:wrap">
                <input id="joinCode" class="input" placeholder="참여용 6자리 코드" maxlength="6"/>
                <button id="btnJoinGo" class="btn alt">연결</button>
                <div id="joinInfo" class="pill">상태: 대기</div>
              </div>

              <div style="width:100%;color:#9eaad0;font-size:12px;margin-top:6px">
                호스트가 생성한 6자리 코드를 공유하고, 참여자는 코드를 입력해 연결합니다. (WebRTC P2P / PeerJS)
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Title -->
      <section id="titleOv" class="overlay" style="display:block;cursor:pointer">
        <div class="ctr">
          <div style="display:grid;gap:18px;place-items:center">
            <h1 style="margin:0;font-size:62px;letter-spacing:.7rem">P o n g</h1>
            <div class="small">화면을 클릭하거나 Enter</div>
          </div>
        </div>
      </section>

      <!-- Mode (하위 모드 슬라이드 추가) -->
      <section id="modeOv" class="overlay">
        <div class="ctr" style="gap:14px">
          <h2 style="margin:0 0 6px;font-size:30px">모드 선택</h2>
          <div class="modes">
            <div class="mode" data-mode="aiai" id="cardAIAI">
              <h3>AI vs AI</h3>
              <div class="small">양쪽 모두 ONNX(실패 시 휴리스틱)</div>
              <div class="sub" id="subAIAI">
                <div class="sub-inner">
                  <div class="chip" data-variant="duel"  data-parent="aiai">1대1</div>
                  <div class="chip" data-variant="quad"  data-parent="aiai">쿼드라퐁(정사각 4인)</div>
                </div>
              </div>
            </div>

            <div class="mode" data-mode="aip" id="cardAIP">
              <h3>AI vs 플레이어</h3>
              <div class="small">오른쪽: ↑/↓ 또는 W/S (플레이어)</div>
              <div class="sub" id="subAIP">
                <div class="sub-inner">
                  <div class="chip" data-variant="duel"  data-parent="aip">1대1</div>
                  <div class="chip" data-variant="quad"  data-parent="aip">쿼드라퐁(정사각 4인 • 1명만 플레이어)</div>
                </div>
              </div>
            </div>
          </div>
          <div class="small">일시정지 P · 재시작 R</div>
        </div>
      </section>

      <!-- Finish -->
      <section id="postOv" class="overlay">
        <div class="ctr" id="postInner"></div>
      </section>

      <!-- Controls -->
      <div class="ctrl">
        <button id="btnTitle" class="btn ghost">타이틀</button>
        <button id="btnReset" class="btn">재시작</button>
        <button id="btnPause" class="btn alt">일시정지</button>
        <div style="margin-left:auto;font-weight:900"><span id="time">–:––</span></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/* ======= Constants (하이퍼 속도 & 연출) ======= */
const W=800,H=600,PW=12,PH=88,BR=8;
const PAD_SPEED=460;
const B_INIT=400, B_MAX=1200, GROW_HIT=1.12, GROW_WALL=1.02;
const ANG_MAX=(38*Math.PI)/180;
const MATCH_SEC=120;
const COLORS={L:'#5B7CFF', R:'#FF6E5A'};
const TRAIL_MAX=110;

/* ======= Canvas/DOM ======= */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d'); ctx.imageSmoothingEnabled=true;
const fpsEl=document.getElementById('fps'), aiDot=document.getElementById('aiDot'), aiTxt=document.getElementById('aiTxt');
const titleOv=document.getElementById('titleOv'), modeOv=document.getElementById('modeOv'), postOv=document.getElementById('postOv'), postInner=document.getElementById('postInner');
const timeEl=document.getElementById('time');

/* ======= Game State ======= */
const S={
  scene:'title', mode:null, modeVariant:'duel', paused:false, last:performance.now(), run:false,
  ball:{x:W/2,y:H/2,vx:B_INIT,vy:0},
  sL:0, sR:0, rallyRight:Math.random()<.5, t:MATCH_SEC,
  L:[], R:[], T:[], B:[], trail:[], speedLines:[], shake:0, scorePop:null
};

/* ======= Helpers ======= */
function show(el,on){ el.style.display=on?'block':'none'; }
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function rr(x,y,w,h,r,c){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fillStyle=c; ctx.fill(); }
function circle(x,y,r,c){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.closePath(); ctx.fillStyle=c; ctx.fill(); }
function bg(){ ctx.clearRect(0,0,W,H); const g=ctx.createLinearGradient(0,0,W,H); g.addColorStop(0,'#0D1434'); g.addColorStop(1,'#0A0F25'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); ctx.fillStyle='rgba(60,80,160,.35)'; for(let y=0;y<H;y+=26) ctx.fillRect(W/2-2,y,4,13); }
function fmt(t){ const m=Math.floor(t/60), s=Math.floor(t%60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }
function speed(b){ return Math.hypot(b.vx,b.vy); }
function setSpeedDir(b, sp, ang){ b.vx=Math.cos(ang)*sp; b.vy=Math.sin(ang)*sp; }
function screenShake(power){ S.shake = Math.max(S.shake, power); }

/* ======= Input ======= */
const Keys=new Map();
addEventListener('keydown',e=>{
  Keys.set(e.code,true);
  if(e.code==='KeyP') S.paused=!S.paused;
  if(e.code==='KeyR') resetRound();
  if(S.scene==='title' && (e.code==='Enter'||e.code==='Space')) titleOv.click();
});
addEventListener('keyup',e=>Keys.set(e.code,false));

/* ======= Title → Mode ======= */
titleOv.addEventListener('click',()=>{ if(S.scene==='title'){ show(titleOv,false); show(modeOv,true); S.scene='mode'; }});

/* ======= 하위 모드 슬라이드 UI ======= */
const cardAIAI=document.getElementById('cardAIAI');
const cardAIP=document.getElementById('cardAIP');
const subAIAI=document.getElementById('subAIAI');
const subAIP=document.getElementById('subAIP');

function toggleSub(sub){
  // 하나만 펼치기
  [subAIAI, subAIP].forEach(s=>{
    if(s===sub){
      s.style.maxHeight = s.style.maxHeight && s.style.maxHeight!=='0px' ? '0px' : '120px';
    }else{
      s.style.maxHeight = '0px';
    }
  });
}
cardAIAI.addEventListener('click', (e)=>{
  if(e.target.classList.contains('chip')) return; // chip은 별도 처리
  toggleSub(subAIAI);
});
cardAIP.addEventListener('click', (e)=>{
  if(e.target.classList.contains('chip')) return;
  toggleSub(subAIP);
});

// 하위 모드 chip 클릭 → startMode(mode, variant)
document.querySelectorAll('.chip').forEach(ch=>{
  ch.addEventListener('click', ()=>{
    const parent = ch.dataset.parent;   // 'aiai' | 'aip'
    const variant= ch.dataset.variant;  // 'duel' | 'quad'
    S.modeVariant = variant;
    S.mode = parent;
    // 모드 오버레이 닫고 시작
    show(modeOv,false); show(postOv,false);
    startMode(parent, variant);
  });
});

/* ======= Buttons ======= */
document.getElementById('btnTitle').onclick=()=>{ S.scene='title'; S.run=false; show(titleOv,true); show(modeOv,false); show(postOv,false); };
document.getElementById('btnReset').onclick=()=> resetRound();
document.getElementById('btnPause').onclick=()=> S.paused=!S.paused;

/* ======= ONNX AI ======= */
let ortSession=null, aiReady=false;
(async()=>{
  try{
    aiTxt.textContent='AI: loading…'; aiDot.className='dot';
    ortSession = await ort.InferenceSession.create('model.onnx',{executionProviders:['wasm']});
    aiReady=true; aiTxt.textContent='AI: loaded'; aiDot.className='dot ok';
  }catch{ aiReady=false; aiTxt.textContent='AI: failed (heuristic)'; aiDot.className='dot warn'; }
})();
function obsLeft(py,oy){
  const bx=(S.ball.x/W)*2-1, by=(S.ball.y/H)*2-1;
  const bvx=clamp(S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1);
  const p=(py/H)*2-1, o=(oy/H)*2-1;
  const rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1);
  return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);
}
function obsRightMirror(py,oy){
  const bx=((W-S.ball.x)/W)*2-1, by=(S.ball.y/H)*2-1;
  const bvx=clamp(-S.ball.vx/B_MAX,-1,1), bvy=clamp(S.ball.vy/B_MAX,-1,1);
  const p=(py/H)*2-1, o=(oy/H)*2-1;
  const rp=clamp((S.ball.y-py)/(H/2),-1,1), ro=clamp((S.ball.y-oy)/(H/2),-1,1);
  return new ort.Tensor('float32', new Float32Array([bx,by,bvx,bvy,p,o,rp,ro]), [1,8]);
}
async function aiActLeft(py,oy){
  if(!aiReady||!ortSession){ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; }
  try{ const out=await ortSession.run({observation:obsLeft(py,oy)}); const k=Object.keys(out)[0]; return ((out[k].data||out[k])[0]|0); }catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; }
}
async function aiActRight(py,oy){
  if(!aiReady||!ortSession){ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; }
  try{ const out=await ortSession.run({observation:obsRightMirror(py,oy)}); const k=Object.keys(out)[0]; return ((out[k].data||out[k])[0]|0); }catch{ return (S.ball.y<py-3)?0:(S.ball.y>py+3)?2:1; }
}

/* ======= Paddles / Modes ======= */
function makePaddle(side,color,upKey,downKey,aiSide){ return {x:0,y:H/2, color, upKey, downKey, aiSide, trail:[]}; }

/* ▼ 쿼드라퐁 전용: 맵 사각형(정사각) 파라미터 */
const QUAD={
  size: 560,           // 정사각형 한 변(렌더는 캔버스 중앙 정렬)
  padLong: 100,        // 상하 패들 길이(가로), 좌우 패들 길이(세로)
  padThick: 12,        // 패들 두께
  marginX: 0,          // 계산용(초기화에서 설정)
  marginY: 0
};

/* ======= 시작 ======= */
function startMode(mode, variant='duel'){
  S.mode = mode;
  S.modeVariant = variant;
  S.sL=0; S.sR=0; S.t=MATCH_SEC; S.paused=false; S.run=true; S.scene='play';
  S.trail.length=0; S.speedLines.length=0; S.scorePop=null;

  // 공 초기화
  S.ball.x=W/2; S.ball.y=H/2;
  const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1);
  S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);

  // 패들 배열 초기화
  S.L=[]; S.R=[]; S.T=[]; S.B=[];

  if(variant==='duel'){
    // 1v1
    if(mode==='aiai'){
      S.L.push(makePaddle('L', COLORS.L, null, null, 'L'));
      S.R.push(makePaddle('R', COLORS.R, null, null, 'R'));
    }else{ // AI vs Player: 오른쪽이 Human (↑/↓ + W/S), "YOU" 표시
      S.L.push(makePaddle('L', COLORS.L, null, null, 'L'));
      const p = makePaddle('R', COLORS.R, 'ArrowUp','ArrowDown', null);
      p.upKey2='KeyW'; p.downKey2='KeyS'; p.isHuman=true; // YOU
      S.R.push(p);
    }
  }else{
    // 쿼드라퐁(정사각 4인) — AI vs AI / AI vs Player(플레이어는 오른쪽만)
    // 플레이필드 오프셋 계산(정사각형을 중앙에 배치)
    QUAD.marginX = (W - QUAD.size)/2;
    QUAD.marginY = (H - QUAD.size)/2;

    // 좌/우(세로 패들), 상/하(가로 패들)
    // 좌우는 y만 이동, 상하는 x만 이동
    const Lp = makePaddle('L', COLORS.L, null, null, (mode==='aiai'?'L': 'L'));
    const Rp = makePaddle('R', COLORS.R, null, null, (mode==='aiai'?'R': null));
    if(mode==='aip'){ Rp.upKey='ArrowUp'; Rp.downKey='ArrowDown'; Rp.upKey2='KeyW'; Rp.downKey2='KeyS'; Rp.isHuman=true; } // YOU

    const Tp = {x: W/2, y: QUAD.marginY+QUAD.padThick/2, color:'#41C9B8', aiSide:'T', trail:[]};
    const Bp = {x: W/2, y: QUAD.marginY+QUAD.size-QUAD.padThick/2, color:'#FFC857', aiSide:'B', trail:[]};

    S.L.push(Lp); S.R.push(Rp); S.T.push(Tp); S.B.push(Bp);
  }

  // 모드 오버레이 닫기
  show(modeOv,false);
}

/* ======= Physics ======= */
function applyVertical(p, act){ // 좌/우 패들: y 이동
  const d=(act===0?-1:(act===2?1:0))*PAD_SPEED*(1/60);
  const minY = (S.modeVariant==='quad') ? (QUAD.marginY + QUAD.padLong/2) : (PH/2);
  const maxY = (S.modeVariant==='quad') ? (QUAD.marginY + QUAD.size - QUAD.padLong/2) : (H-PH/2);
  p.y=clamp(p.y+d, minY, maxY);
}
function applyHorizontal(p, act){ // 상/하 패들: x 이동 (0=LEFT,1=STAY,2=RIGHT로 재사용)
  const d=(act===0?-1:(act===2?1:0))*PAD_SPEED*(1/60);
  const minX = QUAD.marginX + QUAD.padLong/2;
  const maxX = QUAD.marginX + QUAD.size - QUAD.padLong/2;
  p.x=clamp((p.x||W/2)+d, minX, maxX);
}

function circleRect(cx,cy,cr,rx,ry,rw,rh){
  const nx=clamp(cx,rx,rx+rw), ny=clamp(cy,ry,ry+rh);
  const dx=cx-nx, dy=cy-ny;
  return dx*dx+dy*dy<=cr*cr;
}

function bounce(isLeft, py){
  const off=clamp((S.ball.y-py)/(PH/2),-1,1);
  const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_HIT);
  const ang=off*ANG_MAX, dir=isLeft?1:-1;
  S.ball.vx=dir*sp*Math.cos(ang); S.ball.vy=sp*Math.sin(ang);
  S.ball.x+=dir*(PW/2+BR+2); S.ball.y+=(Math.random()*4-2);
  screenShake(8*Math.min(1, sp/B_MAX));
  spawnHitSpark(S.ball.x - dir*8, S.ball.y, dir);
  pushPaddleTrail(isLeft?'L':'R');
  for(let i=0;i<6;i++) S.trail.unshift({x:S.ball.x - dir*i*4, y:S.ball.y+(Math.random()*6-3), heat:1, r:BR+(i%2)});
  if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX;
}

/* 쿼드라퐁: 상/하 충돌 전용 반사 */
function bounceHorizontal(isTop, px){
  // 패들 중앙과의 오프셋을 x축 기준으로 각도 변화
  const off=clamp((S.ball.x - px)/(QUAD.padLong/2), -1, 1);
  const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_HIT);
  const base = isTop ? Math.PI/2 : -Math.PI/2; // 위면 아래로, 아래면 위로
  const ang = base + off*ANG_MAX;
  setSpeedDir(S.ball, sp, ang);
  S.ball.y += (isTop?1:-1)*(QUAD.padThick/2 + BR + 2);
  S.ball.x += (Math.random()*4-2);
  screenShake(8*Math.min(1, sp/B_MAX));
  spawnHitSpark(S.ball.x, S.ball.y + (isTop?8:-8), isTop?1:-1);
}

/* ======= Round ======= */
function resetRound(){
  S.trail.length=0; S.speedLines.length=0; S.scorePop=null;
  if(S.modeVariant==='duel'){
    S.L.forEach(p=>{p.y=H/2; p.trail.length=0;}); S.R.forEach(p=>{p.y=H/2; p.trail.length=0;});
  }else{
    // 쿼드라퐁 재배치
    S.L[0].y = H/2; S.R[0].y = H/2;
    S.T[0].x = W/2; S.B[0].x = W/2;
    S.L[0].trail.length=0; S.R[0].trail.length=0;
  }
  S.ball.x=W/2; S.ball.y=H/2; const a=(Math.random()*0.7-0.35), dir=(S.rallyRight?1:-1);
  S.ball.vx=dir*B_INIT*Math.cos(a); S.ball.vy=B_INIT*Math.sin(a);
}

/* ======= VFX ======= */
function pushPaddleTrail(side){
  let arr;
  if(side==='L') arr = S.L[0]?.trail;
  else if(side==='R') arr = S.R[0]?.trail;
  else if(side==='T') arr = S.T[0]?.trail;
  else if(side==='B') arr = S.B[0]?.trail;
  if(!arr) return;
  if(side==='T'||side==='B') arr.unshift({x:(side==='T'?S.T[0].x:S.B[0].x), a:1});
  else arr.unshift({y:(side==='L'?S.L[0].y:S.R[0].y), a:1});
  if(arr.length>12) arr.length=12;
}
function drawPaddleTrail(p, side){
  for(let i=0;i<p.trail.length;i++){
    const t=p.trail[i]; const a=(1 - i/p.trail.length)*0.25;
    ctx.fillStyle=`rgba(255,255,255,${a*0.08})`;
    if(side==='L') rr(26, (t.y??p.y)-PH/2, PW, PH, 6, ctx.fillStyle);
    else if(side==='R') rr(W-26-PW, (t.y??p.y)-PH/2, PW, PH, 6, ctx.fillStyle);
    else if(side==='T'){ // 가로 패들 잔상(상)
      const x=(t.x??p.x) - QUAD.padLong/2, y=QUAD.marginY;
      rr(x, y, QUAD.padLong, QUAD.padThick, 6, ctx.fillStyle);
    }else if(side==='B'){ // 하
      const x=(t.x??p.x) - QUAD.padLong/2, y=QUAD.marginY+QUAD.size-QUAD.padThick;
      rr(x, y, QUAD.padLong, QUAD.padThick, 6, ctx.fillStyle);
    }
  }
}
const sparks=[];
function spawnHitSpark(x,y,dir){ for(let i=0;i<10;i++){ const ang=(Math.random()*0.9-0.45)+(dir>0?0:Math.PI); const spd=200+Math.random()*400; sparks.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:.25,age:0}); } }
function updateSparks(dt){ for(let i=sparks.length-1;i>=0;i--){ const s=sparks[i]; s.age+=dt; s.x+=s.vx*dt; s.y+=s.vy*dt; s.vx*=0.96; s.vy*=0.96; if(s.age>=s.life) sparks.splice(i,1); } }
function drawSparks(){ ctx.save(); ctx.globalCompositeOperation='lighter'; for(const s of sparks){ const t=1 - s.age/s.life; ctx.fillStyle=`rgba(255,180,80,${0.6*t})`; ctx.beginPath(); ctx.arc(s.x,s.y,2+3*t,0,Math.PI*2); ctx.fill(); } ctx.restore(); }
function spawnSpeedLines(vx,vy){ const sp=Math.hypot(vx,vy), n=Math.floor(clamp((sp-500)/80,0,10)); for(let i=0;i<n;i++){ const ang=Math.atan2(vy,vx)+(Math.random()*0.4-0.2); const len=30+Math.random()*90; const x=S.ball.x - Math.cos(ang)*8, y=S.ball.y - Math.sin(ang)*8; S.speedLines.push({x,y,ang,len,age:0,life:.18}); } if(S.speedLines.length>60) S.speedLines.splice(0,S.speedLines.length-60); }
function updateSpeedLines(dt){ for(let i=S.speedLines.length-1;i>=0;i--){ const l=S.speedLines[i]; l.age+=dt; l.x-=Math.cos(l.ang)*S.ball.vx*dt*0.2; l.y-=Math.sin(l.ang)*S.ball.vy*dt*0.2; if(l.age>=l.life) S.speedLines.splice(i,1); } }
function drawFlameTrail(){ const sp=speed(S.ball), heat=clamp((sp-B_INIT)/(B_MAX-B_INIT),0,1); const trailLen=Math.floor(6+heat*30); S.trail.unshift({x:S.ball.x,y:S.ball.y,heat,r:BR}); if(S.trail.length>TRAIL_MAX) S.trail.length=TRAIL_MAX; ctx.save(); ctx.globalCompositeOperation='lighter'; for(let i=0;i<Math.min(trailLen,S.trail.length); i++){ const p=S.trail[i], t=i/trailLen, a=(1-t)*(0.12+0.55*heat), r=p.r*(1+0.9*(1-t)*(0.25+0.75*heat)); const grad=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r*2.2); grad.addColorStop(0,`rgba(255,70,30,${a*0.7})`); grad.addColorStop(1,`rgba(255,160,60,${a*0.22})`); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(p.x,p.y,r*2.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle=`rgba(255,210,80,${a})`; ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(2,r*0.6),0,Math.PI*2); ctx.fill(); } const a0=0.24+0.5*heat, r0=BR*(2.4+2.2*heat); const g0=ctx.createRadialGradient(S.ball.x, S.ball.y, 0, S.ball.x, S.ball.y, r0); g0.addColorStop(0,`rgba(255,220,100,${a0})`); g0.addColorStop(1,`rgba(255,120,40,0)`); ctx.fillStyle=g0; ctx.beginPath(); ctx.arc(S.ball.x,S.ball.y,r0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
function spawnScorePop(text){ S.scorePop={text,age:0,life:.9}; }
function drawScorePop(dt){ if(!S.scorePop) return; const p=S.scorePop; p.age+=dt; const t=Math.min(1,p.age/p.life), y=H*0.3-30*t, a=(1-t); ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#EAF0FF'; ctx.font='900 44px Inter,system-ui'; ctx.textAlign='center'; ctx.fillText(p.text,W/2,y); ctx.restore(); if(p.age>=p.life) S.scorePop=null; }

/* ======= Render ======= */
function drawArenaQuad(){
  // 정사각형 플레이필드 라인
  ctx.strokeStyle='rgba(140,160,220,.25)'; ctx.lineWidth=2;
  ctx.strokeRect(QUAD.marginX, QUAD.marginY, QUAD.size, QUAD.size);
  // 중앙 가이드 점선
  ctx.fillStyle='rgba(100,130,220,.25)';
  for(let x=QUAD.marginX; x<=QUAD.marginX+QUAD.size; x+=28) ctx.fillRect(x, H/2-1, 14, 2);
  for(let y=QUAD.marginY; y<=QUAD.marginY+QUAD.size; y+=28) ctx.fillRect(W/2-1, y, 2, 14);
}

function draw(dt){
  let ox=0,oy=0; if(S.shake>0){ ox=(Math.random()*2-1)*S.shake; oy=(Math.random()*2-1)*S.shake; S.shake*=0.85; if(S.shake<0.2) S.shake=0; }
  ctx.save(); ctx.translate(ox,oy);
  bg();

  if(S.modeVariant==='quad'){
    drawArenaQuad();
  }

  // 스피드라인/불꽃 → 패들 → 공 → 스파크
  drawSpeedLines();
  drawFlameTrail();

  // 패들 잔상
  if(S.modeVariant==='duel'){
    if(S.L[0]) drawPaddleTrail(S.L[0],'L');
    if(S.R[0]) drawPaddleTrail(S.R[0],'R');
  }else{
    if(S.L[0]) drawPaddleTrail(S.L[0],'L');
    if(S.R[0]) drawPaddleTrail(S.R[0],'R');
    if(S.T[0]) drawPaddleTrail(S.T[0],'T');
    if(S.B[0]) drawPaddleTrail(S.B[0],'B');
  }

  // paddles (duel)
  if(S.modeVariant==='duel'){
    for(const p of S.L){ rr(26, p.y-PH/2, PW, PH, 6, COLORS.L); }
    if(S.R[0]) rr(W-26-PW, S.R[0].y-PH/2, PW, PH, 6, COLORS.R);

    // YOU 라벨 (AI vs 플레이어에서만)
    if(S.mode==='aip' && S.R[0]?.isHuman){
      ctx.fillStyle='#ffffff'; ctx.font='bold 12px Inter,system-ui';
      ctx.textAlign='left'; ctx.fillText('YOU', W-26-PW-34, S.R[0].y-PH/2-8);
    }
  }else{
    // paddles (quad)
    // Left / Right (세로)
    if(S.L[0]) rr(QUAD.marginX-QUAD.padThick, S.L[0].y-QUAD.padLong/2, QUAD.padThick, QUAD.padLong, 6, COLORS.L);
    if(S.R[0]) rr(QUAD.marginX+QUAD.size, S.R[0].y-QUAD.padLong/2, QUAD.padThick, QUAD.padLong, 6, COLORS.R);
    // Top / Bottom (가로)
    if(S.T[0]) rr(S.T[0].x-QUAD.padLong/2, QUAD.marginY-QUAD.padThick, QUAD.padLong, QUAD.padThick, 6, '#41C9B8');
    if(S.B[0]) rr(S.B[0].x-QUAD.padLong/2, QUAD.marginY+QUAD.size, QUAD.padLong, QUAD.padThick, 6, '#FFC857');

    // YOU (AI vs Player에서만 오른쪽)
    if(S.mode==='aip' && S.R[0]?.isHuman){
      ctx.fillStyle='#ffffff'; ctx.font='bold 12px Inter,system-ui';
      ctx.textAlign='left'; ctx.fillText('YOU', QUAD.marginX+QUAD.size+QUAD.padThick+6, S.R[0].y-QUAD.padLong/2-6);
    }
  }

  // ball core
  circle(S.ball.x,S.ball.y,BR,'#101420');
  circle(S.ball.x,S.ball.y,BR-2,'#1b2238');
  circle(S.ball.x,S.ball.y,BR-3,'#FFC857');

  drawSparks();

  // score (duel 표기 그대로 유지)
  ctx.fillStyle='#DCE6FF'; ctx.font='bold 28px Inter,system-ui';
  ctx.textAlign='right'; ctx.fillText(String(S.sL), W*0.5-60,40);
  ctx.textAlign='left'; ctx.fillText(String(S.sR), W*0.5+60,40);

  ctx.restore();
  drawScorePop(dt);
}

/* ======= Loop ======= */
let fpsA=0,fpsN=0;
async function loop(now=performance.now()){
  const dt=Math.min(.05,(now-S.last)/1000); S.last=now;
  fpsA+=dt; fpsN++; if(fpsA>=.5){ fpsEl.textContent=Math.round(fpsN/fpsA)+' fps'; fpsA=0; fpsN=0; }

  if(S.scene==='play' && !S.paused){
    if(S.modeVariant==='duel'){
      // inputs / AI — duel
      if(S.L[0]){
        let act=1;
        if(S.L[0].aiSide==='L') act=await aiActLeft(S.L[0].y, S.R[0]?.y??H/2);
        applyVertical(S.L[0], act);
        if(Math.random()<.6) pushPaddleTrail('L');
      }
      if(S.R[0]){
        let act=1;
        if(S.R[0].isHuman){
          const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false;
          const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false;
          act=up&&!dn?0:dn&&!up?2:1;
        }else if(S.R[0].aiSide==='R'){
          act=await aiActRight(S.R[0].y, S.L[0]?.y??H/2);
        }
        applyVertical(S.R[0], act);
        if(Math.random()<.6) pushPaddleTrail('R');
      }

      // ball move
      S.ball.x+=S.ball.vx*dt; S.ball.y+=S.ball.vy*dt;

      // top/bottom walls
      if(S.ball.y<=BR||S.ball.y>=H-BR){
        S.ball.y = S.ball.y<=BR?BR:H-BR;
        S.ball.vy = S.ball.y===BR?Math.abs(S.ball.vy):-Math.abs(S.ball.vy);
        const cur=speed(S.ball), sp=Math.min(B_MAX, cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang);
        screenShake(4); spawnSpeedLines(S.ball.vx,S.ball.vy);
      }

      // paddles collision
      if(S.ball.vx<0){
        const p=S.L[0]; if(p){ const Lr={x:26,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,Lr.x,Lr.y,Lr.w,Lr.h)) bounce(true,p.y); }
      }else{
        const p=S.R[0]; if(p){ const Rr={x:W-26-PW,y:p.y-PH/2,w:PW,h:PH}; if(circleRect(S.ball.x,S.ball.y,BR,Rr.x,Rr.y,Rr.w,Rr.h)) bounce(false,p.y); }
      }

      // score
      let scored=null; if(S.ball.x<-BR){S.sR++; S.rallyRight=true; scored='RIGHT';} if(S.ball.x>W+BR){S.sL++; S.rallyRight=false; scored='LEFT';}
      if(scored){ spawnScorePop(scored==='LEFT'?'LEFT +1':'RIGHT +1'); screenShake(12); resetRound(); }
      spawnSpeedLines(S.ball.vx,S.ball.vy); updateSparks(dt); updateSpeedLines(dt);

    }else{
      // ====== Quadrapong ======
      // AI/입력: 좌/우(세로), 상/하(가로)
      if(S.L[0]){
        let act=1; // 0=위,2=아래
        // 좌측 AI: 공이 사각 내에 있을 때만 추적
        const targetY=S.ball.y;
        act = (targetY < S.L[0].y-4)?0 : (targetY > S.L[0].y+4)?2 : 1;
        applyVertical(S.L[0], act);
        if(Math.random()<.6) pushPaddleTrail('L');
      }
      if(S.R[0]){
        let act=1;
        if(S.R[0].isHuman){
          const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false;
          const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false;
          act=up&&!dn?0:dn&&!up?2:1;
        }else{
          const targetY=S.ball.y;
          act = (targetY < S.R[0].y-4)?0 : (targetY > S.R[0].y+4)?2 : 1;
        }
        applyVertical(S.R[0], act);
        if(Math.random()<.6) pushPaddleTrail('R');
      }
      if(S.T[0]){
        let act=1; // 0=왼,2=오
        const targetX=S.ball.x;
        act = (targetX < S.T[0].x-4)?0 : (targetX > S.T[0].x+4)?2 : 1;
        applyHorizontal(S.T[0], act);
        if(Math.random()<.6) pushPaddleTrail('T');
      }
      if(S.B[0]){
        let act=1;
        const targetX=S.ball.x;
        act = (targetX < S.B[0].x-4)?0 : (targetX > S.B[0].x+4)?2 : 1;
        applyHorizontal(S.B[0], act);
        if(Math.random()<.6) pushPaddleTrail('B');
      }

      // 공 이동
      S.ball.x+=S.ball.vx*dt; S.ball.y+=S.ball.vy*dt;

      // 사각 필드 안/밖 벽
      // 왼쪽/오른쪽 벽
      if(S.ball.x <= QUAD.marginX+BR){
        // 왼쪽 벽 근처 — 왼쪽 패들과 충돌 판정
        const p=S.L[0];
        const rx=QUAD.marginX-QUAD.padThick, ry=p.y-QUAD.padLong/2, rw=QUAD.padThick, rh=QUAD.padLong;
        if(circleRect(S.ball.x,S.ball.y,BR, rx,ry,rw,rh)) bounce(true, p.y);
        else { // 벽 반사
          S.ball.x=QUAD.marginX+BR; S.ball.vx=Math.abs(S.ball.vx);
          const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang);
          screenShake(4);
        }
      }
      if(S.ball.x >= QUAD.marginX+QUAD.size-BR){
        const p=S.R[0];
        const rx=QUAD.marginX+QUAD.size, ry=p.y-QUAD.padLong/2, rw=QUAD.padThick, rh=QUAD.padLong;
        if(circleRect(S.ball.x,S.ball.y,BR, rx,ry,rw,rh)) bounce(false, p.y);
        else { S.ball.x=QUAD.marginX+QUAD.size-BR; S.ball.vx=-Math.abs(S.ball.vx);
               const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang);
               screenShake(4); }
      }
      // 위/아래 벽
      if(S.ball.y <= QUAD.marginY+BR){
        const p=S.T[0];
        const rx=p.x-QUAD.padLong/2, ry=QUAD.marginY-QUAD.padThick, rw=QUAD.padLong, rh=QUAD.padThick;
        if(circleRect(S.ball.x,S.ball.y,BR, rx,ry,rw,rh)) bounceHorizontal(true, p.x);
        else { S.ball.y=QUAD.marginY+BR; S.ball.vy=Math.abs(S.ball.vy);
               const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang);
               screenShake(4); }
      }
      if(S.ball.y >= QUAD.marginY+QUAD.size-BR){
        const p=S.B[0];
        const rx=p.x-QUAD.padLong/2, ry=QUAD.marginY+QUAD.size, rw=QUAD.padLong, rh=QUAD.padThick;
        if(circleRect(S.ball.x,S.ball.y,BR, rx,ry,rw,rh)) bounceHorizontal(false, p.x);
        else { S.ball.y=QUAD.marginY+QUAD.size-BR; S.ball.vy=-Math.abs(S.ball.vy);
               const cur=speed(S.ball), sp=Math.min(B_MAX,cur*GROW_WALL), ang=Math.atan2(S.ball.vy,S.ball.vx); setSpeedDir(S.ball,sp,ang);
               screenShake(4); }
      }

      // 득점: 쿼드에서는 바깥으로 완전히 나가면 득점(듀얼 룰 유지: 좌/우 점수만 표시)
      let scored=null;
      if(S.ball.x < QUAD.marginX - BR){ S.sR++; S.rallyRight=true; scored='RIGHT'; }
      if(S.ball.x > QUAD.marginX + QUAD.size + BR){ S.sL++; S.rallyRight=false; scored='LEFT'; }
      if(scored){ spawnScorePop(scored==='LEFT'?'LEFT +1':'RIGHT +1'); screenShake(12); resetRound(); }

      spawnSpeedLines(S.ball.vx,S.ball.vy); updateSparks(dt); updateSpeedLines(dt);
    }

    if(S.run){ S.t=Math.max(0,S.t-dt); timeEl.textContent=fmt(S.t); if(S.t===0) endMatch(); }
  }
  draw(dt); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ======= Round / End ======= */
function endMatch(){ S.run=false; show(postOv,true);
  postInner.innerHTML=`<div style="display:grid;gap:12px;place-items:center">
    <div style="font-size:40px;font-weight:900">경기 종료</div>
    <div style="font-weight:900">${S.sL} : ${S.sR}</div>
    <button class="btn alt" onclick="show(postOv,false); show(modeOv,true);">모드로 돌아가기</button>
  </div>`;}

/* ======================= Multiplayer (PeerJS) ======================= */
const NET={isHost:true, roomCode:null, peer:null, conns:new Map(), opened:false, guestAct:1, readyCount:1};
const netBadge=document.getElementById('netBadge');
const multiPanel=document.getElementById('multiPanel'); let panelOpen=false;
document.getElementById('btnMulti').onclick=()=>{ panelOpen=!panelOpen; multiPanel.style.maxHeight=panelOpen?'180px':'0px'; };
const tabHost=document.getElementById('tabHost'), tabJoin=document.getElementById('tabJoin');
const hostUI=document.getElementById('hostUI'), joinUI=document.getElementById('joinUI');
tabHost.onclick=()=>{ tabHost.classList.add('on'); tabJoin.classList.remove('on'); hostUI.style.display='flex'; joinUI.style.display='none'; NET.isHost=true; };
tabJoin.onclick=()=>{ tabJoin.classList.add('on'); tabHost.classList.remove('on'); hostUI.style.display='none'; joinUI.style.display='flex'; NET.isHost=false; };

const hostInfo=document.getElementById('hostInfo'), hostCodeEl=document.getElementById('hostCode'), btnCopy=document.getElementById('btnCopy'), btnStart=document.getElementById('btnStart');
const btnHostGo=document.getElementById('btnHostGo'), btnJoinGo=document.getElementById('btnJoinGo'), joinInfo=document.getElementById('joinInfo'), joinCode=document.getElementById('joinCode');

function makeCode(){ return String(Math.floor(100000+Math.random()*900000)); }
function setBadge(t){ netBadge.textContent=t; }

function createPeer(id){
  return new Promise((res,rej)=>{
    const p=new Peer(id,{debug:1,config:{iceServers:[{urls:'stun:stun.l.google.com:19302'}]}});
    p.on('open',()=>res(p)); p.on('error',rej);
  });
}
function wireConn(conn){
  conn.on('error',()=>{});
  conn.on('close',()=>{ for(const [k,v] of NET.conns.entries()) if(v===conn) NET.conns.delete(k); if(NET.isHost){ NET.readyCount=1+NET.conns.size; btnStart.disabled=NET.readyCount<2; hostInfo.textContent=`상태: 연결 ${NET.readyCount-1}명`; } });
}
function bcast(msg){ for(const c of NET.conns.values()){ try{c.send(msg);}catch{} } }

/* Host */
btnHostGo.onclick=async()=>{
  NET.isHost=true; NET.roomCode=makeCode();
  NET.peer=await createPeer(`PONG-${NET.roomCode}`); NET.opened=true;
  hostInfo.style.display='inline-flex'; hostCodeEl.style.display='inline-flex'; btnCopy.style.display='inline-block';
  hostInfo.textContent='상태: 대기'; hostCodeEl.textContent=`코드: ${NET.roomCode}`; setBadge('호스트 대기');
  NET.peer.on('connection',(conn)=>{
    wireConn(conn);
    conn.on('open',()=>{ NET.conns.set(conn.peer,conn); conn.send({type:'ack'}); NET.readyCount=1+NET.conns.size; hostInfo.textContent=`상태: 연결 ${NET.readyCount-1}명`; btnStart.disabled=NET.readyCount<2; setBadge('호스트 연결됨'); conn.on('data',msg=>{ if(msg?.type==='input') NET.guestAct=msg.act|0; }); });
  });
};
btnCopy.onclick=()=>{ navigator.clipboard.writeText(NET.roomCode); btnCopy.textContent='복사됨'; setTimeout(()=>btnCopy.textContent='코드 복사',900); };
btnStart.onclick=()=>{ if(!NET.isHost||NET.readyCount<2) return;
  const st={ sL:0,sR:0, rallyRight:Math.random()<.5, t:MATCH_SEC, ball:{x:W/2,y:H/2,vx:B_INIT,vy:0} };
  bcast({type:'start',state:st}); applyMatchFromHost(st); startMode('aip','duel'); // 호스트: 게스트가 오른쪽(duel)
  setBadge('호스트 진행중');
};
function applyMatchFromHost(st){ S.sL=st.sL; S.sR=st.sR; S.rallyRight=st.rallyRight; S.t=st.t; S.ball.x=st.ball.x; S.ball.y=st.ball.y; S.ball.vx=st.ball.vx; S.ball.vy=st.ball.vy; S.trail.length=0; }

/* Guest */
btnJoinGo.onclick=async()=>{
  NET.isHost=false; const code=(joinCode.value||'').trim(); if(code.length!==6) { joinInfo.textContent='상태: 코드 확인'; return; }
  NET.peer=await createPeer(`PONG-G-${makeCode()}`); const conn=NET.peer.connect(`PONG-${code}`,{reliable:true}); wireConn(conn);
  conn.on('open',()=>{ NET.conns.set('host',conn); joinInfo.textContent='상태: 연결됨'; setBadge('게스트 연결됨'); });
  conn.on('data',(msg)=>{ if(msg?.type==='ack'){ joinInfo.textContent='상태: 준비완료'; }
    if(msg?.type==='start'){ applyMatchFromHost(msg.state); startMode('aip','duel'); setBadge('게스트 진행중'); }
  });
};

/* Guest: 입력 송신 */
setInterval(()=>{
  if(NET.isHost) return;
  const up=(Keys.get('ArrowUp')||Keys.get('KeyW'))?true:false;
  const dn=(Keys.get('ArrowDown')||Keys.get('KeyS'))?true:false;
  const act=up&&!dn?0:dn&&!up?2:1;
  const h=NET.conns.get('host'); if(h&&h.open) try{h.send({type:'input',act});}catch{}
}, 50);

/* Host: 게스트 입력 반영하여 오른쪽 패들 조작 (AI전엔 미적용) */
const _origLoop=loop;
loop = async function(now=performance.now()){
  if(NET.isHost && S.scene==='play' && !S.paused && S.R[0] && S.mode !== 'aiai' && S.modeVariant==='duel'){
    applyVertical(S.R[0], NET.guestAct|0);
  }
  return _origLoop(now);
};

/* UI: panel open/close + 초기 호스트 탭 */
multiPanel.style.maxHeight='0px';
tabHost.click();
</script>
</body>
</html>
